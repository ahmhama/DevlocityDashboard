{"ast":null,"code":"const postcss = require('postcss');\n\nconst topologicalSort = require('./topologicalSort');\n\nconst declWhitelist = ['composes'];\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`);\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nconst VISITED_MARKER = 1;\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`;\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ');\n}\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\n\n\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings';\n  const visitedId = parentId + '_' + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = [];\n    const siblings = visited[siblingsId];\n    if (Array.isArray(graph[importId])) graph[importId] = graph[importId].concat(siblings);else graph[importId] = siblings.slice();\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const failOnWrongOrder = options.failOnWrongOrder;\n  return css => {\n    const graph = {};\n    const visited = {};\n    const existingImports = {};\n    const importDecls = {};\n    const imports = {};\n    let importIndex = 0;\n    const createImportedName = typeof options.createImportedName !== 'function' ? (importName\n    /*, path*/\n    ) => `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}` : options.createImportedName; // Check the existing imports order and save refs\n\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector);\n\n      if (matches) {\n        const [,\n        /*match*/\n        doubleQuotePath, singleQuotePath] = matches;\n        const importPath = doubleQuotePath || singleQuotePath;\n        addImportToGraph(importPath, 'root', graph, visited);\n        existingImports[importPath] = rule;\n      }\n    }); // Find any declaration that supports imports\n\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports);\n      let tmpSymbols;\n\n      if (matches) {\n        let [,\n        /*match*/\n        symbols, doubleQuotePath, singleQuotePath, global] = matches;\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`);\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath;\n          const parentRule = createParentName(decl.parent, css);\n          addImportToGraph(importPath, parentRule, graph, visited);\n          importDecls[importPath] = decl;\n          imports[importPath] = imports[importPath] || {};\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath);\n            }\n\n            return imports[importPath][s];\n          });\n        }\n\n        decl.value = tmpSymbols.join(' ');\n      }\n    });\n    const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath => importDecls.hasOwnProperty(importPath));\n      const decl = importDecls[importPath];\n      const errMsg = 'Failed to resolve order of composed modules ' + serializeImports(importsOrder.nodes) + '.';\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      });\n    }\n\n    let lastImportRule;\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path];\n      let rule = existingImports[path];\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: {\n            after: '\\n'\n          }\n        });\n        if (lastImportRule) css.insertAfter(lastImportRule, rule);else css.prepend(rule);\n      }\n\n      lastImportRule = rule;\n      if (!importedSymbols) return;\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(postcss.decl({\n          value: importedSymbol,\n          prop: importedSymbols[importedSymbol],\n          raws: {\n            before: '\\n  '\n          }\n        }));\n      });\n    });\n  };\n});","map":{"version":3,"names":["postcss","require","topologicalSort","declWhitelist","declFilter","RegExp","join","matchImports","icssImport","VISITED_MARKER","createParentName","rule","root","index","parent","selector","serializeImports","imports","map","importPath","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","plugin","options","failOnWrongOrder","css","existingImports","importDecls","importIndex","createImportedName","importName","replace","walkRules","matches","exec","doubleQuotePath","singleQuotePath","walkDecls","decl","value","match","tmpSymbols","symbols","global","split","s","parentRule","importsOrder","Error","nodes","find","hasOwnProperty","errMsg","error","word","lastImportRule","forEach","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/postcss-modules-extract-imports/src/index.js"],"sourcesContent":["const postcss = require('postcss')\nconst topologicalSort = require('./topologicalSort')\n\nconst declWhitelist = ['composes']\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`)\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/\n\nconst VISITED_MARKER = 1\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ')\n}\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings'\n  const visitedId = parentId + '_' + importId\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = []\n\n    const siblings = visited[siblingsId]\n\n    if (Array.isArray(graph[importId]))\n      graph[importId] = graph[importId].concat(siblings)\n    else graph[importId] = siblings.slice()\n\n    visited[visitedId] = VISITED_MARKER\n    siblings.push(importId)\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function(\n  options = {}\n) {\n  const failOnWrongOrder = options.failOnWrongOrder\n\n  return css => {\n    const graph = {}\n    const visited = {}\n\n    const existingImports = {}\n    const importDecls = {}\n    const imports = {}\n\n    let importIndex = 0\n\n    const createImportedName = typeof options.createImportedName !== 'function'\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}`\n      : options.createImportedName\n\n    // Check the existing imports order and save refs\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector)\n\n      if (matches) {\n        const [, /*match*/ doubleQuotePath, singleQuotePath] = matches\n        const importPath = doubleQuotePath || singleQuotePath\n\n        addImportToGraph(importPath, 'root', graph, visited)\n\n        existingImports[importPath] = rule\n      }\n    })\n\n    // Find any declaration that supports imports\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports)\n      let tmpSymbols\n\n      if (matches) {\n        let [\n          ,\n          /*match*/ symbols,\n          doubleQuotePath,\n          singleQuotePath,\n          global\n        ] = matches\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`)\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath\n          const parentRule = createParentName(decl.parent, css)\n\n          addImportToGraph(importPath, parentRule, graph, visited)\n\n          importDecls[importPath] = decl\n          imports[importPath] = imports[importPath] || {}\n\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath)\n            }\n\n            return imports[importPath][s]\n          })\n        }\n\n        decl.value = tmpSymbols.join(' ')\n      }\n    })\n\n    const importsOrder = topologicalSort(graph, failOnWrongOrder)\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath =>\n        importDecls.hasOwnProperty(importPath)\n      )\n      const decl = importDecls[importPath]\n\n      const errMsg =\n        'Failed to resolve order of composed modules ' +\n        serializeImports(importsOrder.nodes) +\n        '.'\n\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      })\n    }\n\n    let lastImportRule\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path]\n      let rule = existingImports[path]\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: { after: '\\n' }\n        })\n\n        if (lastImportRule) css.insertAfter(lastImportRule, rule)\n        else css.prepend(rule)\n      }\n\n      lastImportRule = rule\n\n      if (!importedSymbols) return\n\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(\n          postcss.decl({\n            value: importedSymbol,\n            prop: importedSymbols[importedSymbol],\n            raws: { before: '\\n  ' }\n          })\n        )\n      })\n    })\n  }\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}