{"ast":null,"code":"\"use strict\";\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst _ = require('lodash');\n\nconst gzipSize = require('gzip-size');\n\nconst Logger = require('./Logger');\n\nconst Folder = require('./tree/Folder').default;\n\nconst {\n  parseBundle\n} = require('./parseUtils');\n\nconst {\n  createAssetsFilter\n} = require('./utils');\n\nconst FILENAME_QUERY_REGEXP = /\\?.*$/u;\nconst FILENAME_EXTENSIONS = /\\.(js|mjs)$/iu;\nmodule.exports = {\n  getViewerData,\n  readStatsFromFile\n};\n\nfunction getViewerData(bundleStats, bundleDir, opts) {\n  const {\n    logger = new Logger(),\n    excludeAssets = null\n  } = opts || {};\n  const isAssetIncluded = createAssetsFilter(excludeAssets); // Sometimes all the information is located in `children` array (e.g. problem in #10)\n\n  if (_.isEmpty(bundleStats.assets) && !_.isEmpty(bundleStats.children)) {\n    const {\n      children\n    } = bundleStats;\n    bundleStats = bundleStats.children[0]; // Sometimes if there are additional child chunks produced add them as child assets,\n    // leave the 1st one as that is considered the 'root' asset.\n\n    for (let i = 1; i < children.length; i++) {\n      bundleStats.children[i].assets.forEach(asset => {\n        asset.isChild = true;\n        bundleStats.assets.push(asset);\n      });\n    }\n  } else if (!_.isEmpty(bundleStats.children)) {\n    // Sometimes if there are additional child chunks produced add them as child assets\n    bundleStats.children.forEach(child => {\n      child.assets.forEach(asset => {\n        asset.isChild = true;\n        bundleStats.assets.push(asset);\n      });\n    });\n  } // Picking only `*.js or *.mjs` assets from bundle that has non-empty `chunks` array\n\n\n  bundleStats.assets = _.filter(bundleStats.assets, asset => {\n    // Removing query part from filename (yes, somebody uses it for some reason and Webpack supports it)\n    // See #22\n    asset.name = asset.name.replace(FILENAME_QUERY_REGEXP, '');\n    return FILENAME_EXTENSIONS.test(asset.name) && !_.isEmpty(asset.chunks) && isAssetIncluded(asset.name);\n  }); // Trying to parse bundle assets and get real module sizes if `bundleDir` is provided\n\n  let bundlesSources = null;\n  let parsedModules = null;\n\n  if (bundleDir) {\n    bundlesSources = {};\n    parsedModules = {};\n\n    for (const statAsset of bundleStats.assets) {\n      const assetFile = path.join(bundleDir, statAsset.name);\n      let bundleInfo;\n\n      try {\n        bundleInfo = parseBundle(assetFile);\n      } catch (err) {\n        const msg = err.code === 'ENOENT' ? 'no such file' : err.message;\n        logger.warn(`Error parsing bundle asset \"${assetFile}\": ${msg}`);\n        continue;\n      }\n\n      bundlesSources[statAsset.name] = bundleInfo.src;\n\n      _.assign(parsedModules, bundleInfo.modules);\n    }\n\n    if (_.isEmpty(bundlesSources)) {\n      bundlesSources = null;\n      parsedModules = null;\n      logger.warn('\\nNo bundles were parsed. Analyzer will show only original module sizes from stats file.\\n');\n    }\n  }\n\n  const assets = _.transform(bundleStats.assets, (result, statAsset) => {\n    // If asset is a childAsset, then calculate appropriate bundle modules by looking through stats.children\n    const assetBundles = statAsset.isChild ? getChildAssetBundles(bundleStats, statAsset.name) : bundleStats;\n    const modules = assetBundles ? getBundleModules(assetBundles) : [];\n\n    const asset = result[statAsset.name] = _.pick(statAsset, 'size');\n\n    if (bundlesSources && _.has(bundlesSources, statAsset.name)) {\n      asset.parsedSize = Buffer.byteLength(bundlesSources[statAsset.name]);\n      asset.gzipSize = gzipSize.sync(bundlesSources[statAsset.name]);\n    } // Picking modules from current bundle script\n\n\n    asset.modules = _(modules).filter(statModule => assetHasModule(statAsset, statModule)).each(statModule => {\n      if (parsedModules) {\n        statModule.parsedSrc = parsedModules[statModule.id];\n      }\n    });\n    asset.tree = createModulesTree(asset.modules);\n  }, {});\n\n  return _.transform(assets, (result, asset, filename) => {\n    result.push({\n      label: filename,\n      isAsset: true,\n      // Not using `asset.size` here provided by Webpack because it can be very confusing when `UglifyJsPlugin` is used.\n      // In this case all module sizes from stats file will represent unminified module sizes, but `asset.size` will\n      // be the size of minified bundle.\n      // Using `asset.size` only if current asset doesn't contain any modules (resulting size equals 0)\n      statSize: asset.tree.size || asset.size,\n      parsedSize: asset.parsedSize,\n      gzipSize: asset.gzipSize,\n      groups: _.invokeMap(asset.tree.children, 'toChartData')\n    });\n  }, []);\n}\n\nfunction readStatsFromFile(filename) {\n  return JSON.parse(fs.readFileSync(filename, 'utf8'));\n}\n\nfunction getChildAssetBundles(bundleStats, assetName) {\n  return _.find(bundleStats.children, c => _(c.assetsByChunkName).values().flatten().includes(assetName));\n}\n\nfunction getBundleModules(bundleStats) {\n  return _(bundleStats.chunks).map('modules').concat(bundleStats.modules).compact().flatten().uniqBy('id').value();\n}\n\nfunction assetHasModule(statAsset, statModule) {\n  // Checking if this module is the part of asset chunks\n  return _.some(statModule.chunks, moduleChunk => _.includes(statAsset.chunks, moduleChunk));\n}\n\nfunction createModulesTree(modules) {\n  const root = new Folder('.');\n\n  _.each(modules, module => root.addModule(module));\n\n  root.mergeNestedFolders();\n  return root;\n}","map":{"version":3,"names":["fs","require","path","_","gzipSize","Logger","Folder","default","parseBundle","createAssetsFilter","FILENAME_QUERY_REGEXP","FILENAME_EXTENSIONS","module","exports","getViewerData","readStatsFromFile","bundleStats","bundleDir","opts","logger","excludeAssets","isAssetIncluded","isEmpty","assets","children","i","length","forEach","asset","isChild","push","child","filter","name","replace","test","chunks","bundlesSources","parsedModules","statAsset","assetFile","join","bundleInfo","err","msg","code","message","warn","src","assign","modules","transform","result","assetBundles","getChildAssetBundles","getBundleModules","pick","has","parsedSize","Buffer","byteLength","sync","statModule","assetHasModule","each","parsedSrc","id","tree","createModulesTree","filename","label","isAsset","statSize","size","groups","invokeMap","JSON","parse","readFileSync","assetName","find","c","assetsByChunkName","values","flatten","includes","map","concat","compact","uniqBy","value","some","moduleChunk","root","addModule","mergeNestedFolders"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/webpack-bundle-analyzer/lib/analyzer.js"],"sourcesContent":["\"use strict\";\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst _ = require('lodash');\n\nconst gzipSize = require('gzip-size');\n\nconst Logger = require('./Logger');\n\nconst Folder = require('./tree/Folder').default;\n\nconst {\n  parseBundle\n} = require('./parseUtils');\n\nconst {\n  createAssetsFilter\n} = require('./utils');\n\nconst FILENAME_QUERY_REGEXP = /\\?.*$/u;\nconst FILENAME_EXTENSIONS = /\\.(js|mjs)$/iu;\nmodule.exports = {\n  getViewerData,\n  readStatsFromFile\n};\n\nfunction getViewerData(bundleStats, bundleDir, opts) {\n  const {\n    logger = new Logger(),\n    excludeAssets = null\n  } = opts || {};\n  const isAssetIncluded = createAssetsFilter(excludeAssets); // Sometimes all the information is located in `children` array (e.g. problem in #10)\n\n  if (_.isEmpty(bundleStats.assets) && !_.isEmpty(bundleStats.children)) {\n    const {\n      children\n    } = bundleStats;\n    bundleStats = bundleStats.children[0]; // Sometimes if there are additional child chunks produced add them as child assets,\n    // leave the 1st one as that is considered the 'root' asset.\n\n    for (let i = 1; i < children.length; i++) {\n      bundleStats.children[i].assets.forEach(asset => {\n        asset.isChild = true;\n        bundleStats.assets.push(asset);\n      });\n    }\n  } else if (!_.isEmpty(bundleStats.children)) {\n    // Sometimes if there are additional child chunks produced add them as child assets\n    bundleStats.children.forEach(child => {\n      child.assets.forEach(asset => {\n        asset.isChild = true;\n        bundleStats.assets.push(asset);\n      });\n    });\n  } // Picking only `*.js or *.mjs` assets from bundle that has non-empty `chunks` array\n\n\n  bundleStats.assets = _.filter(bundleStats.assets, asset => {\n    // Removing query part from filename (yes, somebody uses it for some reason and Webpack supports it)\n    // See #22\n    asset.name = asset.name.replace(FILENAME_QUERY_REGEXP, '');\n    return FILENAME_EXTENSIONS.test(asset.name) && !_.isEmpty(asset.chunks) && isAssetIncluded(asset.name);\n  }); // Trying to parse bundle assets and get real module sizes if `bundleDir` is provided\n\n  let bundlesSources = null;\n  let parsedModules = null;\n\n  if (bundleDir) {\n    bundlesSources = {};\n    parsedModules = {};\n\n    for (const statAsset of bundleStats.assets) {\n      const assetFile = path.join(bundleDir, statAsset.name);\n      let bundleInfo;\n\n      try {\n        bundleInfo = parseBundle(assetFile);\n      } catch (err) {\n        const msg = err.code === 'ENOENT' ? 'no such file' : err.message;\n        logger.warn(`Error parsing bundle asset \"${assetFile}\": ${msg}`);\n        continue;\n      }\n\n      bundlesSources[statAsset.name] = bundleInfo.src;\n\n      _.assign(parsedModules, bundleInfo.modules);\n    }\n\n    if (_.isEmpty(bundlesSources)) {\n      bundlesSources = null;\n      parsedModules = null;\n      logger.warn('\\nNo bundles were parsed. Analyzer will show only original module sizes from stats file.\\n');\n    }\n  }\n\n  const assets = _.transform(bundleStats.assets, (result, statAsset) => {\n    // If asset is a childAsset, then calculate appropriate bundle modules by looking through stats.children\n    const assetBundles = statAsset.isChild ? getChildAssetBundles(bundleStats, statAsset.name) : bundleStats;\n    const modules = assetBundles ? getBundleModules(assetBundles) : [];\n\n    const asset = result[statAsset.name] = _.pick(statAsset, 'size');\n\n    if (bundlesSources && _.has(bundlesSources, statAsset.name)) {\n      asset.parsedSize = Buffer.byteLength(bundlesSources[statAsset.name]);\n      asset.gzipSize = gzipSize.sync(bundlesSources[statAsset.name]);\n    } // Picking modules from current bundle script\n\n\n    asset.modules = _(modules).filter(statModule => assetHasModule(statAsset, statModule)).each(statModule => {\n      if (parsedModules) {\n        statModule.parsedSrc = parsedModules[statModule.id];\n      }\n    });\n    asset.tree = createModulesTree(asset.modules);\n  }, {});\n\n  return _.transform(assets, (result, asset, filename) => {\n    result.push({\n      label: filename,\n      isAsset: true,\n      // Not using `asset.size` here provided by Webpack because it can be very confusing when `UglifyJsPlugin` is used.\n      // In this case all module sizes from stats file will represent unminified module sizes, but `asset.size` will\n      // be the size of minified bundle.\n      // Using `asset.size` only if current asset doesn't contain any modules (resulting size equals 0)\n      statSize: asset.tree.size || asset.size,\n      parsedSize: asset.parsedSize,\n      gzipSize: asset.gzipSize,\n      groups: _.invokeMap(asset.tree.children, 'toChartData')\n    });\n  }, []);\n}\n\nfunction readStatsFromFile(filename) {\n  return JSON.parse(fs.readFileSync(filename, 'utf8'));\n}\n\nfunction getChildAssetBundles(bundleStats, assetName) {\n  return _.find(bundleStats.children, c => _(c.assetsByChunkName).values().flatten().includes(assetName));\n}\n\nfunction getBundleModules(bundleStats) {\n  return _(bundleStats.chunks).map('modules').concat(bundleStats.modules).compact().flatten().uniqBy('id').value();\n}\n\nfunction assetHasModule(statAsset, statModule) {\n  // Checking if this module is the part of asset chunks\n  return _.some(statModule.chunks, moduleChunk => _.includes(statAsset.chunks, moduleChunk));\n}\n\nfunction createModulesTree(modules) {\n  const root = new Folder('.');\n\n  _.each(modules, module => root.addModule(module));\n\n  root.mergeNestedFolders();\n  return root;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}