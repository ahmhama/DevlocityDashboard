{"ast":null,"code":"// Conditional and repeated task invocation for node and browser.\n\n/*globals setTimeout, define, module */\n(function (globals) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return tryer;\n    });\n  } else if (typeof module !== 'undefined' && module !== null) {\n    module.exports = tryer;\n  } else {\n    globals.tryer = tryer;\n  } // Public function `tryer`.\n  //\n  // Performs some action when pre-requisite conditions are met and/or until\n  // post-requisite conditions are satisfied.\n  //\n  // @option action {function} The function that you want to invoke. Defaults to `() => {}`.\n  //                           If `action` returns a promise, iterations will not end until\n  //                           the promise is resolved or rejected. Alternatively, `action`\n  //                           may take a callback argument, `done`, to signal that it is\n  //                           asynchronous. In that case, you are responsible for calling\n  //                           `done` when the action is finished.\n  //\n  // @option when {function}   Predicate used to test pre-conditions. Should return `false`\n  //                           to postpone `action` or `true` to perform it. Defaults to\n  //                           `() => true`.\n  //\n  // @option until {function}  Predicate used to test post-conditions. Should return `false`\n  //                           to retry `action` or `true` to terminate it. Defaults to\n  //                           `() => true`.\n  //\n  // @option fail {function}   Callback to be invoked if `limit` tries are reached. Defaults\n  //                           to `() => {}`.\n  //\n  // @option pass {function}   Callback to be invoked after `until` has returned truthily.\n  //                           Defaults to `() => {}`.\n  //\n  // @option interval {number} Retry interval in milliseconds. A negative number indicates\n  //                           that subsequent retries should wait for double the interval\n  //                           from the preceding iteration (exponential backoff). Defaults\n  //                           to -1000.\n  //\n  // @option limit {number}    Maximum retry count, at which point the call fails and retries\n  //                           will cease. A negative number indicates that retries should\n  //                           continue indefinitely. Defaults to -1.\n  //\n  // @example\n  //   tryer({\n  //     when: () => db.isConnected,\n  //     action: () => db.insert(user),\n  //     fail () {\n  //       log.error('No database connection, terminating.');\n  //       process.exit(1);\n  //     },\n  //     interval: 1000,\n  //     limit: 10\n  //   });\n  //\n  // @example\n  //   let sent = false;\n  //   tryer({\n  //     until: () => sent,\n  //     action: done => {\n  //       smtp.send(email, error => {\n  //         if (! error) {\n  //           sent = true;\n  //         }\n  //         done();\n  //       });\n  //     },\n  //     pass: next,\n  //     interval: -1000,\n  //     limit: -1\n  //   });\n\n\n  function tryer(options) {\n    options = normaliseOptions(options);\n    iterateWhen();\n\n    function iterateWhen() {\n      if (preRecur()) {\n        iterateUntil();\n      }\n    }\n\n    function preRecur() {\n      return conditionallyRecur('when', iterateWhen);\n    }\n\n    function conditionallyRecur(predicateKey, iterate) {\n      if (!options[predicateKey]()) {\n        incrementCount(options);\n\n        if (shouldFail(options)) {\n          options.fail();\n        } else {\n          recur(iterate, postIncrementInterval(options));\n        }\n\n        return false;\n      }\n\n      return true;\n    }\n\n    function iterateUntil() {\n      var result;\n\n      if (isActionSynchronous(options)) {\n        result = options.action();\n\n        if (result && isFunction(result.then)) {\n          return result.then(postRecur, postRecur);\n        }\n\n        return postRecur();\n      }\n\n      options.action(postRecur);\n    }\n\n    function postRecur() {\n      if (conditionallyRecur('until', iterateUntil)) {\n        options.pass();\n      }\n    }\n  }\n\n  function normaliseOptions(options) {\n    options = options || {};\n    return {\n      count: 0,\n      when: normalisePredicate(options.when),\n      until: normalisePredicate(options.until),\n      action: normaliseFunction(options.action),\n      fail: normaliseFunction(options.fail),\n      pass: normaliseFunction(options.pass),\n      interval: normaliseNumber(options.interval, -1000),\n      limit: normaliseNumber(options.limit, -1)\n    };\n  }\n\n  function normalisePredicate(fn) {\n    return normalise(fn, isFunction, yes);\n  }\n\n  function isFunction(fn) {\n    return typeof fn === 'function';\n  }\n\n  function yes() {\n    return true;\n  }\n\n  function normaliseFunction(fn) {\n    return normalise(fn, isFunction, nop);\n  }\n\n  function nop() {}\n\n  function normalise(thing, predicate, defaultValue) {\n    if (predicate(thing)) {\n      return thing;\n    }\n\n    return defaultValue;\n  }\n\n  function normaliseNumber(number, defaultNumber) {\n    return normalise(number, isNumber, defaultNumber);\n  }\n\n  function isNumber(number) {\n    return typeof number === 'number' && number === number;\n  }\n\n  function isActionSynchronous(options) {\n    return options.action.length === 0;\n  }\n\n  function incrementCount(options) {\n    options.count += 1;\n  }\n\n  function shouldFail(options) {\n    return options.limit >= 0 && options.count >= options.limit;\n  }\n\n  function postIncrementInterval(options) {\n    var currentInterval = options.interval;\n\n    if (options.interval < 0) {\n      options.interval *= 2;\n    }\n\n    return currentInterval;\n  }\n\n  function recur(fn, interval) {\n    setTimeout(fn, Math.abs(interval));\n  }\n})(this);","map":{"version":3,"names":["globals","define","amd","tryer","module","exports","options","normaliseOptions","iterateWhen","preRecur","iterateUntil","conditionallyRecur","predicateKey","iterate","incrementCount","shouldFail","fail","recur","postIncrementInterval","result","isActionSynchronous","action","isFunction","then","postRecur","pass","count","when","normalisePredicate","until","normaliseFunction","interval","normaliseNumber","limit","fn","normalise","yes","nop","thing","predicate","defaultValue","number","defaultNumber","isNumber","length","currentInterval","setTimeout","Math","abs"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/tryer/src/tryer.js"],"sourcesContent":["// Conditional and repeated task invocation for node and browser.\n\n/*globals setTimeout, define, module */\n\n(function (globals) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return tryer;\n    });\n  } else if (typeof module !== 'undefined' && module !== null) {\n    module.exports = tryer;\n  } else {\n    globals.tryer = tryer;\n  }\n\n  // Public function `tryer`.\n  //\n  // Performs some action when pre-requisite conditions are met and/or until\n  // post-requisite conditions are satisfied.\n  //\n  // @option action {function} The function that you want to invoke. Defaults to `() => {}`.\n  //                           If `action` returns a promise, iterations will not end until\n  //                           the promise is resolved or rejected. Alternatively, `action`\n  //                           may take a callback argument, `done`, to signal that it is\n  //                           asynchronous. In that case, you are responsible for calling\n  //                           `done` when the action is finished.\n  //\n  // @option when {function}   Predicate used to test pre-conditions. Should return `false`\n  //                           to postpone `action` or `true` to perform it. Defaults to\n  //                           `() => true`.\n  //\n  // @option until {function}  Predicate used to test post-conditions. Should return `false`\n  //                           to retry `action` or `true` to terminate it. Defaults to\n  //                           `() => true`.\n  //\n  // @option fail {function}   Callback to be invoked if `limit` tries are reached. Defaults\n  //                           to `() => {}`.\n  //\n  // @option pass {function}   Callback to be invoked after `until` has returned truthily.\n  //                           Defaults to `() => {}`.\n  //\n  // @option interval {number} Retry interval in milliseconds. A negative number indicates\n  //                           that subsequent retries should wait for double the interval\n  //                           from the preceding iteration (exponential backoff). Defaults\n  //                           to -1000.\n  //\n  // @option limit {number}    Maximum retry count, at which point the call fails and retries\n  //                           will cease. A negative number indicates that retries should\n  //                           continue indefinitely. Defaults to -1.\n  //\n  // @example\n  //   tryer({\n  //     when: () => db.isConnected,\n  //     action: () => db.insert(user),\n  //     fail () {\n  //       log.error('No database connection, terminating.');\n  //       process.exit(1);\n  //     },\n  //     interval: 1000,\n  //     limit: 10\n  //   });\n  //\n  // @example\n  //   let sent = false;\n  //   tryer({\n  //     until: () => sent,\n  //     action: done => {\n  //       smtp.send(email, error => {\n  //         if (! error) {\n  //           sent = true;\n  //         }\n  //         done();\n  //       });\n  //     },\n  //     pass: next,\n  //     interval: -1000,\n  //     limit: -1\n  //   });\n  function tryer (options) {\n    options = normaliseOptions(options);\n\n    iterateWhen();\n\n    function iterateWhen () {\n      if (preRecur()) {\n        iterateUntil();\n      }\n    }\n\n    function preRecur () {\n      return conditionallyRecur('when', iterateWhen);\n    }\n\n    function conditionallyRecur (predicateKey, iterate) {\n      if (! options[predicateKey]()) {\n        incrementCount(options);\n\n        if (shouldFail(options)) {\n          options.fail();\n        }  else {\n          recur(iterate, postIncrementInterval(options));\n        }\n\n        return false;\n      }\n\n      return true;\n    }\n\n    function iterateUntil () {\n      var result;\n\n      if (isActionSynchronous(options)) {\n        result = options.action();\n\n        if (result && isFunction(result.then)) {\n          return result.then(postRecur, postRecur);\n        }\n\n        return postRecur();\n      }\n\n      options.action(postRecur);\n    }\n\n    function postRecur () {\n      if (conditionallyRecur('until', iterateUntil)) {\n        options.pass();\n      }\n    }\n  }\n\n  function normaliseOptions (options) {\n    options = options || {};\n    return {\n      count: 0,\n      when: normalisePredicate(options.when),\n      until: normalisePredicate(options.until),\n      action: normaliseFunction(options.action),\n      fail: normaliseFunction(options.fail),\n      pass: normaliseFunction(options.pass),\n      interval: normaliseNumber(options.interval, -1000),\n      limit: normaliseNumber(options.limit, -1)\n    };\n  }\n\n  function normalisePredicate (fn) {\n    return normalise(fn, isFunction, yes);\n  }\n\n  function isFunction (fn) {\n    return typeof fn === 'function';\n  }\n\n  function yes () {\n    return true;\n  }\n\n  function normaliseFunction (fn) {\n    return normalise(fn, isFunction, nop);\n  }\n\n  function nop () {\n  }\n\n  function normalise (thing, predicate, defaultValue) {\n    if (predicate(thing)) {\n      return thing;\n    }\n\n    return defaultValue;\n  }\n\n  function normaliseNumber (number, defaultNumber) {\n    return normalise(number, isNumber, defaultNumber);\n  }\n\n  function isNumber (number) {\n    return typeof number === 'number' && number === number;\n  }\n\n  function isActionSynchronous (options) {\n    return options.action.length === 0;\n  }\n\n  function incrementCount (options) {\n    options.count += 1;\n  }\n\n  function shouldFail (options) {\n    return options.limit >= 0 && options.count >= options.limit;\n  }\n\n  function postIncrementInterval (options) {\n    var currentInterval = options.interval;\n\n    if (options.interval < 0) {\n      options.interval *= 2;\n    }\n\n    return currentInterval;\n  }\n\n  function recur (fn, interval) {\n    setTimeout(fn, Math.abs(interval));\n  }\n}(this));\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}