{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\n\nconst events = require('./events');\n\nconst promise = require('./promise');\n\nconst walk = require('./walk');\n\nmodule.exports = parse;\nconst NDJSON_STATE = new Map();\n/**\n * Public function `parse`.\n *\n * Returns a promise and asynchronously parses a stream of JSON data. If\n * there are no errors, the promise is resolved with the parsed data. If\n * errors occur, the promise is rejected with the first error.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option reviver:   Transformation function, invoked depth-first.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON. In\n *                    this case, each call will be resolved with one value\n *                    from the stream. To parse the entire stream, calls\n *                    should be made sequentially one-at-a-time until the\n *                    returned promise resolves to `undefined`.\n **/\n\nfunction parse(stream) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const Promise = promise(options);\n\n  try {\n    check.assert.maybe.function(options.reviver, 'Invalid reviver option');\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const errors = [];\n  const scopes = [];\n  const reviver = options.reviver;\n  const shouldHandleNdjson = !!options.ndjson;\n  let emitter, resolve, reject, scopeKey;\n\n  if (shouldHandleNdjson && NDJSON_STATE.has(stream)) {\n    const state = NDJSON_STATE.get(stream);\n    NDJSON_STATE.delete(stream);\n    emitter = state.emitter;\n    setImmediate(state.resume);\n  } else {\n    emitter = walk(stream, options);\n  }\n\n  emitter.on(events.array, array);\n  emitter.on(events.object, object);\n  emitter.on(events.property, property);\n  emitter.on(events.string, value);\n  emitter.on(events.number, value);\n  emitter.on(events.literal, value);\n  emitter.on(events.endArray, endScope);\n  emitter.on(events.endObject, endScope);\n  emitter.on(events.end, end);\n  emitter.on(events.error, error);\n  emitter.on(events.dataError, error);\n\n  if (shouldHandleNdjson) {\n    emitter.on(events.endLine, endLine);\n  }\n\n  return new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  function array() {\n    if (errors.length > 0) {\n      return;\n    }\n\n    beginScope([]);\n  }\n\n  function beginScope(parsed) {\n    if (errors.length > 0) {\n      return;\n    }\n\n    if (scopes.length > 0) {\n      value(parsed);\n    }\n\n    scopes.push(parsed);\n  }\n\n  function value(v) {\n    if (errors.length > 0) {\n      return;\n    }\n\n    if (scopes.length === 0) {\n      return scopes.push(v);\n    }\n\n    const scope = scopes[scopes.length - 1];\n\n    if (scopeKey) {\n      scope[scopeKey] = v;\n      scopeKey = null;\n    } else {\n      scope.push(v);\n    }\n  }\n\n  function object() {\n    if (errors.length > 0) {\n      return;\n    }\n\n    beginScope({});\n  }\n\n  function property(name) {\n    if (errors.length > 0) {\n      return;\n    }\n\n    scopeKey = name;\n  }\n\n  function endScope() {\n    if (errors.length > 0) {\n      return;\n    }\n\n    if (scopes.length > 1) {\n      scopes.pop();\n    }\n  }\n\n  function end() {\n    if (shouldHandleNdjson) {\n      const resume = emitter.pause();\n      emitter.removeAllListeners();\n      NDJSON_STATE.set(stream, {\n        emitter,\n        resume\n      });\n    }\n\n    if (errors.length > 0) {\n      return reject(errors[0]);\n    }\n\n    if (reviver) {\n      scopes[0] = transform(scopes[0], '');\n    }\n\n    resolve(scopes[0]);\n  }\n\n  function transform(obj, key) {\n    if (obj && typeof obj === 'object') {\n      Object.keys(obj).forEach(childKey => {\n        obj[childKey] = transform(obj[childKey], childKey);\n      });\n    }\n\n    return reviver(key, obj);\n  }\n\n  function error(e) {\n    errors.push(e);\n  }\n\n  function endLine() {\n    if (scopes.length > 0) {\n      end();\n    }\n  }\n}","map":{"version":3,"names":["check","require","events","promise","walk","module","exports","parse","NDJSON_STATE","Map","stream","options","Promise","assert","maybe","function","reviver","err","reject","errors","scopes","shouldHandleNdjson","ndjson","emitter","resolve","scopeKey","has","state","get","delete","setImmediate","resume","on","array","object","property","string","value","number","literal","endArray","endScope","endObject","end","error","dataError","endLine","res","rej","length","beginScope","parsed","push","v","scope","name","pop","pause","removeAllListeners","set","transform","obj","key","Object","keys","forEach","childKey","e"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/bfj/src/parse.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst events = require('./events')\nconst promise = require('./promise')\nconst walk = require('./walk')\n\nmodule.exports = parse\n\nconst NDJSON_STATE = new Map()\n\n/**\n * Public function `parse`.\n *\n * Returns a promise and asynchronously parses a stream of JSON data. If\n * there are no errors, the promise is resolved with the parsed data. If\n * errors occur, the promise is rejected with the first error.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option reviver:   Transformation function, invoked depth-first.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON. In\n *                    this case, each call will be resolved with one value\n *                    from the stream. To parse the entire stream, calls\n *                    should be made sequentially one-at-a-time until the\n *                    returned promise resolves to `undefined`.\n **/\nfunction parse (stream, options = {}) {\n  const Promise = promise(options)\n\n  try {\n    check.assert.maybe.function(options.reviver, 'Invalid reviver option')\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  const errors = []\n  const scopes = []\n  const reviver = options.reviver\n  const shouldHandleNdjson = !! options.ndjson\n\n  let emitter, resolve, reject, scopeKey\n  if (shouldHandleNdjson && NDJSON_STATE.has(stream)) {\n    const state = NDJSON_STATE.get(stream)\n    NDJSON_STATE.delete(stream)\n    emitter = state.emitter\n    setImmediate(state.resume)\n  } else {\n    emitter = walk(stream, options)\n  }\n\n  emitter.on(events.array, array)\n  emitter.on(events.object, object)\n  emitter.on(events.property, property)\n  emitter.on(events.string, value)\n  emitter.on(events.number, value)\n  emitter.on(events.literal, value)\n  emitter.on(events.endArray, endScope)\n  emitter.on(events.endObject, endScope)\n  emitter.on(events.end, end)\n  emitter.on(events.error, error)\n  emitter.on(events.dataError, error)\n\n  if (shouldHandleNdjson) {\n    emitter.on(events.endLine, endLine)\n  }\n\n  return new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  function array () {\n    if (errors.length > 0) {\n      return\n    }\n\n    beginScope([])\n  }\n\n  function beginScope (parsed) {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length > 0) {\n      value(parsed)\n    }\n\n    scopes.push(parsed)\n  }\n\n  function value (v) {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length === 0) {\n      return scopes.push(v)\n    }\n\n    const scope = scopes[scopes.length - 1]\n\n    if (scopeKey) {\n      scope[scopeKey] = v\n      scopeKey = null\n    } else {\n      scope.push(v)\n    }\n  }\n\n  function object () {\n    if (errors.length > 0) {\n      return\n    }\n\n    beginScope({})\n  }\n\n  function property (name) {\n    if (errors.length > 0) {\n      return\n    }\n\n    scopeKey = name\n  }\n\n  function endScope () {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length > 1) {\n      scopes.pop()\n    }\n  }\n\n  function end () {\n    if (shouldHandleNdjson) {\n      const resume = emitter.pause()\n      emitter.removeAllListeners()\n      NDJSON_STATE.set(stream, { emitter, resume })\n    }\n\n    if (errors.length > 0) {\n      return reject(errors[0])\n    }\n\n    if (reviver) {\n      scopes[0] = transform(scopes[0], '')\n    }\n\n    resolve(scopes[0])\n  }\n\n  function transform (obj, key) {\n    if (obj && typeof obj === 'object') {\n      Object.keys(obj).forEach(childKey => {\n        obj[childKey] = transform(obj[childKey], childKey)\n      })\n    }\n\n    return reviver(key, obj)\n  }\n\n  function error (e) {\n    errors.push(e)\n  }\n\n  function endLine () {\n    if (scopes.length > 0) {\n      end()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}