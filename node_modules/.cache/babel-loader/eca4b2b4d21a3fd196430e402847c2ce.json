{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _mapGenerator = _interopRequireDefault(require(\"./map-generator\"));\n\nvar _stringify2 = _interopRequireDefault(require(\"./stringify\"));\n\nvar _warnOnce = _interopRequireDefault(require(\"./warn-once\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\n\n\nvar LazyResult = /*#__PURE__*/function () {\n  function LazyResult(processor, css, opts) {\n    this.stringified = false;\n    this.processed = false;\n    var root;\n\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n\n\n  var _proto = LazyResult.prototype;\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n\n  _proto.warnings = function warnings() {\n    return this.sync().warnings();\n  }\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  ;\n\n  _proto.toString = function toString() {\n    return this.css;\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  ;\n\n  _proto.then = function then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  ;\n\n  _proto.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  ;\n\n  _proto.finally = function _finally(onFinally) {\n    return this.async().then(onFinally, onFinally);\n  };\n\n  _proto.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          var pluginName = plugin.postcssPlugin;\n          var pluginVer = plugin.postcssVersion;\n          var runtimeVer = this.result.processor.version;\n          var a = pluginVer.split('.');\n          var b = runtimeVer.split('.');\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  _proto.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  _proto.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  _proto.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done;) {\n      var plugin = _step.value;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  _proto.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  _proto.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify2.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: \"processor\",\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     *\n     * @type {processOptions}\n     */\n\n  }, {\n    key: \"opts\",\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: \"css\",\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: \"content\",\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: \"map\",\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: \"messages\",\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nvar _default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["lazy-result.es6"],"names":["obj","LazyResult","css","root","Result","opts","parser","parse","warnings","toString","then","process","catch","finally","handleError","error","plugin","pluginName","pluginVer","runtimeVer","a","b","parseInt","console","asyncTick","resolve","promise","isPromise","reject","async","sync","run","stringify","str","map","MapGenerator","data"],"mappings":"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","sourcesContent":["import MapGenerator from './map-generator'\nimport stringify from './stringify'\nimport warnOnce from './warn-once'\nimport Result from './result'\nimport parse from './parse'\n\nfunction isPromise (obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\nclass LazyResult {\n  constructor (processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = css.root\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = { }\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.error = error\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n  }\n\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n  get processor () {\n    return this.result.processor\n  }\n\n  /**\n   * Options from the {@link Processor#process} call.\n   *\n   * @type {processOptions}\n   */\n  get opts () {\n    return this.result.opts\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins, converts `Root`\n   * to a CSS string and returns {@link Result#css}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#css\n   */\n  get css () {\n    return this.stringify().css\n  }\n\n  /**\n   * An alias for the `css` property. Use it with syntaxes\n   * that generate non-CSS output.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#content\n   */\n  get content () {\n    return this.stringify().content\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#map}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {SourceMapGenerator}\n   * @see Result#map\n   */\n  get map () {\n    return this.stringify().map\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#root}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Root}\n   * @see Result#root\n   */\n  get root () {\n    return this.sync().root\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#messages}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Message[]}\n   * @see Result#messages\n   */\n  get messages () {\n    return this.sync().messages\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n  warnings () {\n    return this.sync().warnings()\n  }\n\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  toString () {\n    return this.css\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  then (onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n          'and will not find Browserslist config. Set it to CSS file path ' +\n          'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  catch (onRejected) {\n    return this.async().catch(onRejected)\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  finally (onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  handleError (error, plugin) {\n    try {\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n              'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' +\n              pluginVer + '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err)\n    }\n  }\n\n  asyncTick (resolve, reject) {\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true\n      return resolve()\n    }\n\n    try {\n      let plugin = this.processor.plugins[this.plugin]\n      let promise = this.run(plugin)\n      this.plugin += 1\n\n      if (isPromise(promise)) {\n        promise.then(() => {\n          this.asyncTick(resolve, reject)\n        }).catch(error => {\n          this.handleError(error, plugin)\n          this.processed = true\n          reject(error)\n        })\n      } else {\n        this.asyncTick(resolve, reject)\n      }\n    } catch (error) {\n      this.processed = true\n      reject(error)\n    }\n  }\n\n  async () {\n    if (this.processed) {\n      return new Promise((resolve, reject) => {\n        if (this.error) {\n          reject(this.error)\n        } else {\n          resolve(this.stringify())\n        }\n      })\n    }\n    if (this.processing) {\n      return this.processing\n    }\n\n    this.processing = new Promise((resolve, reject) => {\n      if (this.error) return reject(this.error)\n      this.plugin = 0\n      this.asyncTick(resolve, reject)\n    }).then(() => {\n      this.processed = true\n      return this.stringify()\n    })\n\n    return this.processing\n  }\n\n  sync () {\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw new Error(\n        'Use process(css).then(cb) to work with async plugins')\n    }\n\n    if (this.error) throw this.error\n\n    for (let plugin of this.result.processor.plugins) {\n      let promise = this.run(plugin)\n      if (isPromise(promise)) {\n        throw new Error(\n          'Use process(css).then(cb) to work with async plugins')\n      }\n    }\n\n    return this.result\n  }\n\n  run (plugin) {\n    this.result.lastPlugin = plugin\n\n    try {\n      return plugin(this.result.root, this.result)\n    } catch (error) {\n      this.handleError(error, plugin)\n      throw error\n    }\n  }\n\n  stringify () {\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n}\n\nexport default LazyResult\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"script"}