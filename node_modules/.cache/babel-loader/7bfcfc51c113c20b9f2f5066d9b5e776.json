{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst valueParser = require('postcss-value-parser');\n\nconst {\n  extractICSS\n} = require('icss-utils');\n\nconst isSpacing = node => node.type === 'combinator' && node.value === ' ';\n\nfunction getImportLocalAliases(icssImports) {\n  const localAliases = new Map();\n  Object.keys(icssImports).forEach(key => {\n    Object.keys(icssImports[key]).forEach(prop => {\n      localAliases.set(prop, icssImports[key][prop]);\n    });\n  });\n  return localAliases;\n}\n\nfunction maybeLocalizeValue(value, localAliasMap) {\n  if (localAliasMap.has(value)) return value;\n}\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n  nodes.forEach(function (x) {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(function (item) {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const isScopePseudo = node => node.value === ':local' || node.value === ':global';\n\n  const isImportExportPseudo = node => node.value === ':import' || node.value === ':export';\n\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error('Missing whitespace after ' + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error('Missing whitespace before ' + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case 'root':\n        {\n          let resultingGlobal;\n          context.hasPureGlobals = false;\n          newNodes = node.nodes.map(function (n) {\n            const nContext = {\n              global: context.global,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: false\n            };\n            n = transform(n, nContext);\n\n            if (typeof resultingGlobal === 'undefined') {\n              resultingGlobal = nContext.global;\n            } else if (resultingGlobal !== nContext.global) {\n              throw new Error('Inconsistent rule global/local result in rule \"' + node + '\" (multiple selectors must result in the same mode for the rule)');\n            }\n\n            if (!nContext.hasLocals) {\n              context.hasPureGlobals = true;\n            }\n\n            return n;\n          });\n          context.global = resultingGlobal;\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case 'selector':\n        {\n          newNodes = node.map(childNode => transform(childNode, context));\n          node = node.clone();\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case 'combinator':\n        {\n          if (isSpacing(node)) {\n            if (context.ignoreNextSpacing) {\n              context.ignoreNextSpacing = false;\n              context.lastWasSpacing = false;\n              context.enforceNoSpacing = false;\n              return null;\n            }\n\n            context.lastWasSpacing = true;\n            return node;\n          }\n\n          break;\n        }\n\n      case 'pseudo':\n        {\n          let childContext;\n          const isNested = !!node.length;\n          const isScoped = isScopePseudo(node);\n          const isImportExport = isImportExportPseudo(node);\n\n          if (isImportExport) {\n            context.hasLocals = true; // :local(.foo)\n          } else if (isNested) {\n            if (isScoped) {\n              if (node.nodes.length === 0) {\n                throw new Error(`${node.value}() can't be empty`);\n              }\n\n              if (context.inside) {\n                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n              }\n\n              childContext = {\n                global: node.value === ':global',\n                inside: node.value,\n                hasLocals: false,\n                explicit: true\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);\n\n              if (newNodes.length) {\n                const {\n                  before,\n                  after\n                } = node.spaces;\n                const first = newNodes[0];\n                const last = newNodes[newNodes.length - 1];\n                first.spaces = {\n                  before,\n                  after: first.spaces.after\n                };\n                last.spaces = {\n                  before: last.spaces.before,\n                  after\n                };\n              }\n\n              node = newNodes;\n              break;\n            } else {\n              childContext = {\n                global: context.global,\n                inside: context.inside,\n                lastWasSpacing: true,\n                hasLocals: false,\n                explicit: context.explicit\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext));\n              node = node.clone();\n              node.nodes = normalizeNodeArray(newNodes);\n\n              if (childContext.hasLocals) {\n                context.hasLocals = true;\n              }\n            }\n\n            break; //:local .foo .bar\n          } else if (isScoped) {\n            if (context.inside) {\n              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n            }\n\n            const addBackSpacing = !!node.spaces.before;\n            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;\n            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;\n            context.global = node.value === ':global';\n            context.explicit = true; // because this node has spacing that is lost when we remove it\n            // we make up for it by adding an extra combinator in since adding\n            // spacing on the parent selector doesn't work\n\n            return addBackSpacing ? selectorParser.combinator({\n              value: ' '\n            }) : null;\n          }\n\n          break;\n        }\n\n      case 'id':\n      case 'class':\n        {\n          if (!node.value) {\n            throw new Error('Invalid class or id selector syntax');\n          }\n\n          if (context.global) {\n            break;\n          }\n\n          const isImportedValue = localAliasMap.has(node.value);\n          const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n          if (!isImportedValue || isImportedWithExplicitScope) {\n            const innerNode = node.clone();\n            innerNode.spaces = {\n              before: '',\n              after: ''\n            };\n            node = selectorParser.pseudo({\n              value: ':local',\n              nodes: [innerNode],\n              spaces: node.spaces\n            });\n            context.hasLocals = true;\n          }\n\n          break;\n        }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === 'global',\n    hasPureGlobals: false\n  };\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, {\n    updateSelector: false,\n    lossless: true\n  });\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case 'word':\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = ':local(' + node.value + ')';\n          context.localizeNextItem = false;\n        }\n      }\n\n      break;\n\n    case 'function':\n      if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === 'url') {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== 'string' && nestedNode.type !== 'word') {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);\n\n          switch (nestedNode.type) {\n            case 'string':\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n\n            case 'word':\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, '\\\\$1');\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n\n      break;\n  }\n\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode ? functionNode.nodes.some(functionNodeChild => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;\n}\n\nfunction localizeAnimationShorthandDeclValues(decl, context) {\n  const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n  /*\n  The spec defines some keywords that you can use to describe properties such as the timing\n  function. These are still valid animation names, so as long as there is a property that accepts\n  a keyword, it is given priority. Only when all the properties that can take a keyword are\n  exhausted can the animation name be set to the keyword. I.e.\n   animation: infinite infinite;\n   The animation will repeat an infinite number of times from the first argument, and will have an\n  animation name of infinite from the second.\n  */\n\n  const animationKeywords = {\n    $alternate: 1,\n    '$alternate-reverse': 1,\n    $backwards: 1,\n    $both: 1,\n    $ease: 1,\n    '$ease-in': 1,\n    '$ease-in-out': 1,\n    '$ease-out': 1,\n    $forwards: 1,\n    $infinite: 1,\n    $linear: 1,\n    $none: Infinity,\n    // No matter how many times you write none, it will never be an animation name\n    $normal: 1,\n    $paused: 1,\n    $reverse: 1,\n    $running: 1,\n    '$step-end': 1,\n    '$step-start': 1,\n    $initial: Infinity,\n    $inherit: Infinity,\n    $unset: Infinity\n  };\n  const didParseAnimationName = false;\n  let parsedAnimationKeywords = {};\n  let stepsFunctionNode = null;\n  const valueNodes = valueParser(decl.value).walk(node => {\n    /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n    if (node.type === 'div') {\n      parsedAnimationKeywords = {};\n    }\n\n    if (node.type === 'function' && node.value.toLowerCase() === 'steps') {\n      stepsFunctionNode = node;\n    }\n\n    const value = node.type === 'word' && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;\n    let shouldParseAnimationName = false;\n\n    if (!didParseAnimationName && value && validIdent.test(value)) {\n      if ('$' + value in animationKeywords) {\n        parsedAnimationKeywords['$' + value] = '$' + value in parsedAnimationKeywords ? parsedAnimationKeywords['$' + value] + 1 : 0;\n        shouldParseAnimationName = parsedAnimationKeywords['$' + value] >= animationKeywords['$' + value];\n      } else {\n        shouldParseAnimationName = true;\n      }\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: shouldParseAnimationName && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    return localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDeclValues(localize, decl, context) {\n  const valueNodes = valueParser(decl.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDecl(decl, context) {\n  const isAnimation = /animation$/i.test(decl.prop);\n\n  if (isAnimation) {\n    return localizeAnimationShorthandDeclValues(decl, context);\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(decl.prop);\n\n  if (isAnimationName) {\n    return localizeDeclValues(true, decl, context);\n  }\n\n  const hasUrl = /url\\(/i.test(decl.value);\n\n  if (hasUrl) {\n    return localizeDeclValues(false, decl, context);\n  }\n}\n\nmodule.exports = postcss.plugin('postcss-modules-local-by-default', function (options) {\n  if (typeof options !== 'object') {\n    options = {}; // If options is undefined or not an object the plugin fails\n  }\n\n  if (options && options.mode) {\n    if (options.mode !== 'global' && options.mode !== 'local' && options.mode !== 'pure') {\n      throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n    }\n  }\n\n  const pureMode = options && options.mode === 'pure';\n  const globalMode = options && options.mode === 'global';\n  return function (css) {\n    const {\n      icssImports\n    } = extractICSS(css, false);\n    const localAliasMap = getImportLocalAliases(icssImports);\n    css.walkAtRules(function (atrule) {\n      if (/keyframes$/i.test(atrule.name)) {\n        const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        let globalKeyframes = globalMode;\n\n        if (globalMatch) {\n          if (pureMode) {\n            throw atrule.error('@keyframes :global(...) is not allowed in pure mode');\n          }\n\n          atrule.params = globalMatch[1];\n          globalKeyframes = true;\n        } else if (localMatch) {\n          atrule.params = localMatch[0];\n          globalKeyframes = false;\n        } else if (!globalMode) {\n          if (atrule.params && !localAliasMap.has(atrule.params)) atrule.params = ':local(' + atrule.params + ')';\n        }\n\n        atrule.walkDecls(function (decl) {\n          localizeDecl(decl, {\n            localAliasMap,\n            options: options,\n            global: globalKeyframes\n          });\n        });\n      } else if (atrule.nodes) {\n        atrule.nodes.forEach(function (decl) {\n          if (decl.type === 'decl') {\n            localizeDecl(decl, {\n              localAliasMap,\n              options: options,\n              global: globalMode\n            });\n          }\n        });\n      }\n    });\n    css.walkRules(function (rule) {\n      if (rule.parent && rule.parent.type === 'atrule' && /keyframes$/i.test(rule.parent.name)) {\n        // ignore keyframe rules\n        return;\n      }\n\n      if (rule.nodes && rule.selector.slice(0, 2) === '--' && rule.selector.slice(-1) === ':') {\n        // ignore custom property set\n        return;\n      }\n\n      const context = localizeNode(rule, options.mode, localAliasMap);\n      context.options = options;\n      context.localAliasMap = localAliasMap;\n\n      if (pureMode && context.hasPureGlobals) {\n        throw rule.error('Selector \"' + rule.selector + '\" is not pure ' + '(pure selectors must contain at least one local class or id)');\n      }\n\n      rule.selector = context.selector; // Less-syntax mixins parse as rules with no nodes\n\n      if (rule.nodes) {\n        rule.nodes.forEach(decl => localizeDecl(decl, context));\n      }\n    });\n  };\n});","map":{"version":3,"names":["postcss","require","selectorParser","valueParser","extractICSS","isSpacing","node","type","value","getImportLocalAliases","icssImports","localAliases","Map","Object","keys","forEach","key","prop","set","maybeLocalizeValue","localAliasMap","has","normalizeNodeArray","nodes","array","x","Array","isArray","item","push","length","pop","localizeNode","rule","mode","isScopePseudo","isImportExportPseudo","transform","context","ignoreNextSpacing","Error","enforceNoSpacing","newNodes","resultingGlobal","hasPureGlobals","map","n","nContext","global","lastWasSpacing","hasLocals","explicit","childNode","clone","childContext","isNested","isScoped","isImportExport","inside","reduce","acc","next","concat","before","after","spaces","first","last","addBackSpacing","combinator","isImportedValue","isImportedWithExplicitScope","innerNode","pseudo","rootContext","selector","root","processSync","updateSelector","lossless","localizeDeclNode","localizeNextItem","options","rewriteUrl","toLowerCase","nestedNode","newUrl","quote","replace","isWordAFunctionArgument","wordNode","functionNode","some","functionNodeChild","sourceIndex","localizeAnimationShorthandDeclValues","decl","validIdent","animationKeywords","$alternate","$backwards","$both","$ease","$forwards","$infinite","$linear","$none","Infinity","$normal","$paused","$reverse","$running","$initial","$inherit","$unset","didParseAnimationName","parsedAnimationKeywords","stepsFunctionNode","valueNodes","walk","shouldParseAnimationName","test","subContext","toString","localizeDeclValues","localize","index","localizeDecl","isAnimation","isAnimationName","hasUrl","module","exports","plugin","pureMode","globalMode","css","walkAtRules","atrule","name","globalMatch","exec","params","localMatch","globalKeyframes","error","walkDecls","walkRules","parent","slice"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/postcss-modules-local-by-default/index.js"],"sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst selectorParser = require('postcss-selector-parser');\nconst valueParser = require('postcss-value-parser');\nconst { extractICSS } = require('icss-utils');\n\nconst isSpacing = node => node.type === 'combinator' && node.value === ' ';\n\nfunction getImportLocalAliases(icssImports) {\n  const localAliases = new Map();\n  Object.keys(icssImports).forEach(key => {\n    Object.keys(icssImports[key]).forEach(prop => {\n      localAliases.set(prop, icssImports[key][prop]);\n    });\n  });\n  return localAliases;\n}\n\nfunction maybeLocalizeValue(value, localAliasMap) {\n  if (localAliasMap.has(value)) return value;\n}\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach(function(x) {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(function(item) {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const isScopePseudo = node =>\n    node.value === ':local' || node.value === ':global';\n  const isImportExportPseudo = node =>\n    node.value === ':import' || node.value === ':export';\n\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error('Missing whitespace after ' + context.ignoreNextSpacing);\n    }\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error('Missing whitespace before ' + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n    switch (node.type) {\n      case 'root': {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map(function(n) {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === 'undefined') {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case 'selector': {\n        newNodes = node.map(childNode => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case 'combinator': {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case 'pseudo': {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = isScopePseudo(node);\n        const isImportExport = isImportExportPseudo(node);\n\n        if (isImportExport) {\n          context.hasLocals = true;\n        // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${\n                  context.inside\n                }(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === ':global',\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map(childNode => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map(childNode =>\n              transform(childNode, childContext)\n            );\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${\n                context.inside\n              }(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === ':global';\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser.combinator({ value: ' ' })\n            : null;\n        }\n        break;\n      }\n      case 'id':\n      case 'class': {\n        if (!node.value) {\n          throw new Error('Invalid class or id selector syntax');\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: '', after: '' };\n\n          node = selectorParser.pseudo({\n            value: ':local',\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === 'global',\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case 'word':\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = ':local(' + node.value + ')';\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case 'function':\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === 'url'\n      ) {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== 'string' && nestedNode.type !== 'word') {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case 'string':\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case 'word':\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, '\\\\$1');\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode\n    ? functionNode.nodes.some(\n        functionNodeChild =>\n          functionNodeChild.sourceIndex === wordNode.sourceIndex\n      )\n    : false;\n}\n\nfunction localizeAnimationShorthandDeclValues(decl, context) {\n  const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n  /*\n  The spec defines some keywords that you can use to describe properties such as the timing\n  function. These are still valid animation names, so as long as there is a property that accepts\n  a keyword, it is given priority. Only when all the properties that can take a keyword are\n  exhausted can the animation name be set to the keyword. I.e.\n\n  animation: infinite infinite;\n\n  The animation will repeat an infinite number of times from the first argument, and will have an\n  animation name of infinite from the second.\n  */\n  const animationKeywords = {\n    $alternate: 1,\n    '$alternate-reverse': 1,\n    $backwards: 1,\n    $both: 1,\n    $ease: 1,\n    '$ease-in': 1,\n    '$ease-in-out': 1,\n    '$ease-out': 1,\n    $forwards: 1,\n    $infinite: 1,\n    $linear: 1,\n    $none: Infinity, // No matter how many times you write none, it will never be an animation name\n    $normal: 1,\n    $paused: 1,\n    $reverse: 1,\n    $running: 1,\n    '$step-end': 1,\n    '$step-start': 1,\n    $initial: Infinity,\n    $inherit: Infinity,\n    $unset: Infinity,\n  };\n\n  const didParseAnimationName = false;\n  let parsedAnimationKeywords = {};\n  let stepsFunctionNode = null;\n  const valueNodes = valueParser(decl.value).walk(node => {\n    /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n    if (node.type === 'div') {\n      parsedAnimationKeywords = {};\n    }\n    if (node.type === 'function' && node.value.toLowerCase() === 'steps') {\n      stepsFunctionNode = node;\n    }\n    const value =\n      node.type === 'word' && !isWordAFunctionArgument(node, stepsFunctionNode)\n        ? node.value.toLowerCase()\n        : null;\n\n    let shouldParseAnimationName = false;\n\n    if (!didParseAnimationName && value && validIdent.test(value)) {\n      if ('$' + value in animationKeywords) {\n        parsedAnimationKeywords['$' + value] =\n          '$' + value in parsedAnimationKeywords\n            ? parsedAnimationKeywords['$' + value] + 1\n            : 0;\n\n        shouldParseAnimationName =\n          parsedAnimationKeywords['$' + value] >=\n          animationKeywords['$' + value];\n      } else {\n        shouldParseAnimationName = true;\n      }\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: shouldParseAnimationName && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    return localizeDeclNode(node, subContext);\n  });\n\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDeclValues(localize, decl, context) {\n  const valueNodes = valueParser(decl.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDecl(decl, context) {\n  const isAnimation = /animation$/i.test(decl.prop);\n\n  if (isAnimation) {\n    return localizeAnimationShorthandDeclValues(decl, context);\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(decl.prop);\n\n  if (isAnimationName) {\n    return localizeDeclValues(true, decl, context);\n  }\n\n  const hasUrl = /url\\(/i.test(decl.value);\n\n  if (hasUrl) {\n    return localizeDeclValues(false, decl, context);\n  }\n}\n\nmodule.exports = postcss.plugin('postcss-modules-local-by-default', function(\n  options\n) {\n  if (typeof options !== 'object') {\n    options = {}; // If options is undefined or not an object the plugin fails\n  }\n\n  if (options && options.mode) {\n    if (\n      options.mode !== 'global' &&\n      options.mode !== 'local' &&\n      options.mode !== 'pure'\n    ) {\n      throw new Error(\n        'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n      );\n    }\n  }\n\n  const pureMode = options && options.mode === 'pure';\n  const globalMode = options && options.mode === 'global';\n\n  return function(css) {\n    const { icssImports } = extractICSS(css, false);\n    const localAliasMap = getImportLocalAliases(icssImports);\n\n    css.walkAtRules(function(atrule) {\n      if (/keyframes$/i.test(atrule.name)) {\n        const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        let globalKeyframes = globalMode;\n        if (globalMatch) {\n          if (pureMode) {\n            throw atrule.error(\n              '@keyframes :global(...) is not allowed in pure mode'\n            );\n          }\n          atrule.params = globalMatch[1];\n          globalKeyframes = true;\n        } else if (localMatch) {\n          atrule.params = localMatch[0];\n          globalKeyframes = false;\n        } else if (!globalMode) {\n          if (atrule.params && !localAliasMap.has(atrule.params))\n            atrule.params = ':local(' + atrule.params + ')';\n        }\n        atrule.walkDecls(function(decl) {\n          localizeDecl(decl, {\n            localAliasMap,\n            options: options,\n            global: globalKeyframes,\n          });\n        });\n      } else if (atrule.nodes) {\n        atrule.nodes.forEach(function(decl) {\n          if (decl.type === 'decl') {\n            localizeDecl(decl, {\n              localAliasMap,\n              options: options,\n              global: globalMode,\n            });\n          }\n        });\n      }\n    });\n\n    css.walkRules(function(rule) {\n      if (\n        rule.parent &&\n        rule.parent.type === 'atrule' &&\n        /keyframes$/i.test(rule.parent.name)\n      ) {\n        // ignore keyframe rules\n        return;\n      }\n\n      if (\n        rule.nodes &&\n        rule.selector.slice(0, 2) === '--' &&\n        rule.selector.slice(-1) === ':'\n      ) {\n        // ignore custom property set\n        return;\n      }\n\n      const context = localizeNode(rule, options.mode, localAliasMap);\n\n      context.options = options;\n      context.localAliasMap = localAliasMap;\n\n      if (pureMode && context.hasPureGlobals) {\n        throw rule.error(\n          'Selector \"' +\n            rule.selector +\n            '\" is not pure ' +\n            '(pure selectors must contain at least one local class or id)'\n        );\n      }\n\n      rule.selector = context.selector;\n\n      // Less-syntax mixins parse as rules with no nodes\n      if (rule.nodes) {\n        rule.nodes.forEach(decl => localizeDecl(decl, context));\n      }\n    });\n  };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}