{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\n\nconst eventify = require('./eventify');\n\nconst events = require('./events');\n\nconst JsonStream = require('./jsonstream');\n\nconst Hoopy = require('hoopy');\n\nconst promise = require('./promise');\n\nconst tryer = require('tryer');\n\nconst DEFAULT_BUFFER_LENGTH = 1024;\nmodule.exports = streamify;\n/**\n * Public function `streamify`.\n *\n * Asynchronously serialises a data structure to a stream of JSON\n * data. Sanely handles promises, buffers, maps and other iterables.\n *\n * @param data:           The data to transform.\n *\n * @option space:         Indentation string, or the number of spaces\n *                        to indent each nested level by.\n *\n * @option promises:      'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:       'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:          'object' or 'ignore', default is 'object'.\n *\n * @option iterables:     'array' or 'ignore', default is 'array'.\n *\n * @option circular:      'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\n\nfunction streamify(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const emitter = eventify(data, options);\n  const json = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH);\n  const Promise = promise(options);\n  const space = normaliseSpace(options);\n  let streamOptions;\n  const {\n    highWaterMark\n  } = options;\n\n  if (highWaterMark) {\n    streamOptions = {\n      highWaterMark\n    };\n  }\n\n  const stream = new JsonStream(read, streamOptions);\n  let awaitPush = true;\n  let index = 0;\n  let indentation = '';\n  let isEnded;\n  let isPaused = false;\n  let isProperty;\n  let length = 0;\n  let mutex = Promise.resolve();\n  let needsComma;\n  emitter.on(events.array, noRacing(array));\n  emitter.on(events.object, noRacing(object));\n  emitter.on(events.property, noRacing(property));\n  emitter.on(events.string, noRacing(string));\n  emitter.on(events.number, noRacing(value));\n  emitter.on(events.literal, noRacing(value));\n  emitter.on(events.endArray, noRacing(endArray));\n  emitter.on(events.endObject, noRacing(endObject));\n  emitter.on(events.end, noRacing(end));\n  emitter.on(events.error, noRacing(error));\n  emitter.on(events.dataError, noRacing(dataError));\n  return stream;\n\n  function read() {\n    if (awaitPush) {\n      awaitPush = false;\n\n      if (isEnded) {\n        if (length > 0) {\n          after();\n        }\n\n        return endStream();\n      }\n    }\n\n    if (isPaused) {\n      after();\n    }\n  }\n\n  function after() {\n    if (awaitPush) {\n      return;\n    }\n\n    let i;\n\n    for (i = 0; i < length && !awaitPush; ++i) {\n      if (!stream.push(json[i + index], 'utf8')) {\n        awaitPush = true;\n      }\n    }\n\n    if (i === length) {\n      index = length = 0;\n    } else {\n      length -= i;\n      index += i;\n    }\n  }\n\n  function endStream() {\n    if (!awaitPush) {\n      stream.push(null);\n    }\n  }\n\n  function noRacing(handler) {\n    return eventData => mutex = mutex.then(() => handler(eventData));\n  }\n\n  function array() {\n    return beforeScope().then(() => addJson('[')).then(() => afterScope());\n  }\n\n  function beforeScope() {\n    return before(true);\n  }\n\n  function before(isScope) {\n    if (isProperty) {\n      isProperty = false;\n\n      if (space) {\n        return addJson(' ');\n      }\n\n      return Promise.resolve();\n    }\n\n    return Promise.resolve().then(() => {\n      if (needsComma) {\n        if (isScope) {\n          needsComma = false;\n        }\n\n        return addJson(',');\n      }\n\n      if (!isScope) {\n        needsComma = true;\n      }\n    }).then(() => {\n      if (space && indentation) {\n        return indent();\n      }\n    });\n  }\n\n  function addJson(chunk) {\n    if (length + 1 <= json.length) {\n      json[index + length++] = chunk;\n      after();\n      return Promise.resolve();\n    }\n\n    isPaused = true;\n    return new Promise(resolve => {\n      const unpause = emitter.pause();\n      tryer({\n        interval: -10,\n\n        until() {\n          return length + 1 <= json.length;\n        },\n\n        pass() {\n          isPaused = false;\n          json[index + length++] = chunk;\n          resolve();\n          setImmediate(unpause);\n        }\n\n      });\n    });\n  }\n\n  function indent() {\n    return addJson(`\\n${indentation}`);\n  }\n\n  function afterScope() {\n    needsComma = false;\n\n    if (space) {\n      indentation += space;\n    }\n  }\n\n  function object() {\n    return beforeScope().then(() => addJson('{')).then(() => afterScope());\n  }\n\n  function property(name) {\n    return before().then(() => addJson(`\"${name}\":`)).then(() => {\n      isProperty = true;\n    });\n  }\n\n  function string(s) {\n    return value(`\"${s}\"`);\n  }\n\n  function value(v) {\n    return before().then(() => addJson(`${v}`));\n  }\n\n  function endArray() {\n    return beforeScopeEnd().then(() => addJson(']')).then(() => afterScopeEnd());\n  }\n\n  function beforeScopeEnd() {\n    if (space) {\n      indentation = indentation.substr(space.length);\n      return indent();\n    }\n\n    return Promise.resolve();\n  }\n\n  function afterScopeEnd() {\n    needsComma = true;\n  }\n\n  function endObject() {\n    return beforeScopeEnd().then(() => addJson('}')).then(() => afterScopeEnd());\n  }\n\n  function end() {\n    after();\n    isEnded = true;\n    endStream();\n  }\n\n  function error(err) {\n    stream.emit('error', err);\n  }\n\n  function dataError(err) {\n    stream.emit('dataError', err);\n  }\n}\n\nfunction normaliseSpace(options) {\n  if (check.positive(options.space)) {\n    return new Array(options.space + 1).join(' ');\n  }\n\n  if (check.nonEmptyString(options.space)) {\n    return options.space;\n  }\n}","map":{"version":3,"names":["check","require","eventify","events","JsonStream","Hoopy","promise","tryer","DEFAULT_BUFFER_LENGTH","module","exports","streamify","data","options","emitter","json","bufferLength","Promise","space","normaliseSpace","streamOptions","highWaterMark","stream","read","awaitPush","index","indentation","isEnded","isPaused","isProperty","length","mutex","resolve","needsComma","on","array","noRacing","object","property","string","number","value","literal","endArray","endObject","end","error","dataError","after","endStream","i","push","handler","eventData","then","beforeScope","addJson","afterScope","before","isScope","indent","chunk","unpause","pause","interval","until","pass","setImmediate","name","s","v","beforeScopeEnd","afterScopeEnd","substr","err","emit","positive","Array","join","nonEmptyString"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/bfj/src/streamify.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst eventify = require('./eventify')\nconst events = require('./events')\nconst JsonStream = require('./jsonstream')\nconst Hoopy = require('hoopy')\nconst promise = require('./promise')\nconst tryer = require('tryer')\n\nconst DEFAULT_BUFFER_LENGTH = 1024\n\nmodule.exports = streamify\n\n/**\n * Public function `streamify`.\n *\n * Asynchronously serialises a data structure to a stream of JSON\n * data. Sanely handles promises, buffers, maps and other iterables.\n *\n * @param data:           The data to transform.\n *\n * @option space:         Indentation string, or the number of spaces\n *                        to indent each nested level by.\n *\n * @option promises:      'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:       'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:          'object' or 'ignore', default is 'object'.\n *\n * @option iterables:     'array' or 'ignore', default is 'array'.\n *\n * @option circular:      'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction streamify (data, options = {}) {\n  const emitter = eventify(data, options)\n  const json = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH)\n  const Promise = promise(options)\n  const space = normaliseSpace(options)\n  let streamOptions\n  const { highWaterMark } = options\n  if (highWaterMark) {\n    streamOptions = { highWaterMark }\n  }\n  const stream = new JsonStream(read, streamOptions)\n\n  let awaitPush = true\n  let index = 0\n  let indentation = ''\n  let isEnded\n  let isPaused = false\n  let isProperty\n  let length = 0\n  let mutex = Promise.resolve()\n  let needsComma\n\n  emitter.on(events.array, noRacing(array))\n  emitter.on(events.object, noRacing(object))\n  emitter.on(events.property, noRacing(property))\n  emitter.on(events.string, noRacing(string))\n  emitter.on(events.number, noRacing(value))\n  emitter.on(events.literal, noRacing(value))\n  emitter.on(events.endArray, noRacing(endArray))\n  emitter.on(events.endObject, noRacing(endObject))\n  emitter.on(events.end, noRacing(end))\n  emitter.on(events.error, noRacing(error))\n  emitter.on(events.dataError, noRacing(dataError))\n\n  return stream\n\n  function read () {\n    if (awaitPush) {\n      awaitPush = false\n\n      if (isEnded) {\n        if (length > 0) {\n          after()\n        }\n\n        return endStream()\n      }\n    }\n\n    if (isPaused) {\n      after()\n    }\n  }\n\n  function after () {\n    if (awaitPush) {\n      return\n    }\n\n    let i\n\n    for (i = 0; i < length && ! awaitPush; ++i) {\n      if (! stream.push(json[i + index], 'utf8')) {\n        awaitPush = true\n      }\n    }\n\n    if (i === length) {\n      index = length = 0\n    } else {\n      length -= i\n      index += i\n    }\n  }\n\n  function endStream () {\n    if (! awaitPush) {\n      stream.push(null)\n    }\n  }\n\n  function noRacing (handler) {\n    return eventData => mutex = mutex.then(() => handler(eventData))\n  }\n\n  function array () {\n    return beforeScope()\n      .then(() => addJson('['))\n      .then(() => afterScope())\n  }\n\n  function beforeScope () {\n    return before(true)\n  }\n\n  function before (isScope) {\n    if (isProperty) {\n      isProperty = false\n\n      if (space) {\n        return addJson(' ')\n      }\n\n      return Promise.resolve()\n    }\n\n    return Promise.resolve()\n      .then(() => {\n        if (needsComma) {\n          if (isScope) {\n            needsComma = false\n          }\n\n          return addJson(',')\n        }\n\n        if (! isScope) {\n          needsComma = true\n        }\n      })\n      .then(() => {\n        if (space && indentation) {\n          return indent()\n        }\n      })\n  }\n\n  function addJson (chunk) {\n    if (length + 1 <= json.length) {\n      json[index + length++] = chunk\n      after()\n      return Promise.resolve()\n    }\n\n    isPaused = true\n    return new Promise(resolve => {\n      const unpause = emitter.pause()\n      tryer({\n        interval: -10,\n        until () {\n          return length + 1 <= json.length\n        },\n        pass () {\n          isPaused = false\n          json[index + length++] = chunk\n          resolve()\n          setImmediate(unpause)\n        }\n      })\n    })\n  }\n\n  function indent () {\n    return addJson(`\\n${indentation}`)\n  }\n\n  function afterScope () {\n    needsComma = false\n\n    if (space) {\n      indentation += space\n    }\n  }\n\n  function object () {\n    return beforeScope()\n      .then(() => addJson('{'))\n      .then(() => afterScope())\n  }\n\n  function property (name) {\n    return before()\n      .then(() => addJson(`\"${name}\":`))\n      .then(() => {\n        isProperty = true\n      })\n  }\n\n  function string (s) {\n    return value(`\"${s}\"`)\n  }\n\n  function value (v) {\n    return before()\n      .then(() => addJson(`${v}`))\n  }\n\n  function endArray () {\n    return beforeScopeEnd()\n      .then(() => addJson(']'))\n      .then(() => afterScopeEnd())\n  }\n\n  function beforeScopeEnd () {\n    if (space) {\n      indentation = indentation.substr(space.length)\n\n      return indent()\n    }\n\n    return Promise.resolve()\n  }\n\n  function afterScopeEnd () {\n    needsComma = true\n  }\n\n  function endObject () {\n    return beforeScopeEnd()\n      .then(() => addJson('}'))\n      .then(() => afterScopeEnd())\n  }\n\n  function end () {\n    after()\n\n    isEnded = true\n    endStream()\n  }\n\n  function error (err) {\n    stream.emit('error', err)\n  }\n\n  function dataError (err) {\n    stream.emit('dataError', err)\n  }\n}\n\nfunction normaliseSpace (options) {\n  if (check.positive(options.space)) {\n    return new Array(options.space + 1).join(' ')\n  }\n\n  if (check.nonEmptyString(options.space)) {\n    return options.space\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}