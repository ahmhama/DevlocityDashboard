{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\n\nconst error = require('./error');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst events = require('./events');\n\nconst promise = require('./promise');\n\nconst terminators = {\n  obj: '}',\n  arr: ']'\n};\nconst escapes = {\n  /* eslint-disable quote-props */\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  /* eslint-enable quote-props */\n\n};\nmodule.exports = initialise;\n/**\n * Public function `walk`.\n *\n * Returns an event emitter and asynchronously walks a stream of JSON data,\n * emitting events as it encounters tokens. The event emitter is decorated\n * with a `pause` method that can be called to pause processing.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON.\n **/\n\nfunction initialise(stream) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument');\n  const currentPosition = {\n    line: 1,\n    column: 1\n  };\n  const emitter = new EventEmitter();\n  const handlers = {\n    arr: value,\n    obj: property\n  };\n  const json = [];\n  const lengths = [];\n  const previousPosition = {};\n  const Promise = promise(options);\n  const scopes = [];\n  const yieldRate = options.yieldRate || 16384;\n  const shouldHandleNdjson = !!options.ndjson;\n  let index = 0;\n  let isStreamEnded = false;\n  let isWalkBegun = false;\n  let isWalkEnded = false;\n  let isWalkingString = false;\n  let hasEndedLine = true;\n  let count = 0;\n  let resumeFn;\n  let pause;\n  let cachedCharacter;\n  stream.setEncoding('utf8');\n  stream.on('data', readStream);\n  stream.on('end', endStream);\n  stream.on('error', err => {\n    emitter.emit(events.error, err);\n    endStream();\n  });\n\n  emitter.pause = () => {\n    let resolve;\n    pause = new Promise(res => resolve = res);\n    return () => {\n      pause = null;\n      count = 0;\n\n      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {\n        emit(events.end);\n      } else {\n        resolve();\n      }\n    };\n  };\n\n  return emitter;\n\n  function readStream(chunk) {\n    addChunk(chunk);\n\n    if (isWalkBegun) {\n      return resume();\n    }\n\n    isWalkBegun = true;\n    value();\n  }\n\n  function addChunk(chunk) {\n    json.push(chunk);\n    const chunkLength = chunk.length;\n    lengths.push({\n      item: chunkLength,\n      aggregate: length() + chunkLength\n    });\n  }\n\n  function length() {\n    const chunkCount = lengths.length;\n\n    if (chunkCount === 0) {\n      return 0;\n    }\n\n    return lengths[chunkCount - 1].aggregate;\n  }\n\n  function value() {\n    /* eslint-disable no-underscore-dangle */\n    if (++count % yieldRate !== 0) {\n      return _do();\n    }\n\n    return new Promise(resolve => {\n      setImmediate(() => _do().then(resolve));\n    });\n\n    function _do() {\n      return awaitNonWhitespace().then(next).then(handleValue).catch(() => {});\n    }\n    /* eslint-enable no-underscore-dangle */\n\n  }\n\n  function awaitNonWhitespace() {\n    return wait();\n\n    function wait() {\n      return awaitCharacter().then(step);\n    }\n\n    function step() {\n      if (isWhitespace(character())) {\n        return next().then(wait);\n      }\n    }\n  }\n\n  function awaitCharacter() {\n    let resolve, reject;\n\n    if (index < length()) {\n      return Promise.resolve();\n    }\n\n    if (isStreamEnded) {\n      setImmediate(endWalk);\n      return Promise.reject();\n    }\n\n    resumeFn = after;\n    return new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    function after() {\n      if (index < length()) {\n        return resolve();\n      }\n\n      reject();\n\n      if (isStreamEnded) {\n        setImmediate(endWalk);\n      }\n    }\n  }\n\n  function character() {\n    if (cachedCharacter) {\n      return cachedCharacter;\n    }\n\n    if (lengths[0].item > index) {\n      return cachedCharacter = json[0][index];\n    }\n\n    const len = lengths.length;\n\n    for (let i = 1; i < len; ++i) {\n      const {\n        aggregate,\n        item\n      } = lengths[i];\n\n      if (aggregate > index) {\n        return cachedCharacter = json[i][index + item - aggregate];\n      }\n    }\n  }\n\n  function isWhitespace(char) {\n    switch (char) {\n      case '\\n':\n        if (shouldHandleNdjson && scopes.length === 0) {\n          return false;\n        }\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n        return true;\n    }\n\n    return false;\n  }\n\n  function next() {\n    return awaitCharacter().then(after);\n\n    function after() {\n      const result = character();\n      cachedCharacter = null;\n      index += 1;\n      previousPosition.line = currentPosition.line;\n      previousPosition.column = currentPosition.column;\n\n      if (result === '\\n') {\n        currentPosition.line += 1;\n        currentPosition.column = 1;\n      } else {\n        currentPosition.column += 1;\n      }\n\n      if (index > lengths[0].aggregate) {\n        json.shift();\n        const difference = lengths.shift().item;\n        index -= difference;\n        lengths.forEach(len => len.aggregate -= difference);\n      }\n\n      return result;\n    }\n  }\n\n  function handleValue(char) {\n    if (shouldHandleNdjson && scopes.length === 0) {\n      if (char === '\\n') {\n        hasEndedLine = true;\n        return emit(events.endLine).then(value);\n      }\n\n      if (!hasEndedLine) {\n        return fail(char, '\\n', previousPosition).then(value);\n      }\n\n      hasEndedLine = false;\n    }\n\n    switch (char) {\n      case '[':\n        return array();\n\n      case '{':\n        return object();\n\n      case '\"':\n        return string();\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n      case '.':\n        return number(char);\n\n      case 'f':\n        return literalFalse();\n\n      case 'n':\n        return literalNull();\n\n      case 't':\n        return literalTrue();\n\n      default:\n        return fail(char, 'value', previousPosition).then(value);\n    }\n  }\n\n  function array() {\n    return scope(events.array, value);\n  }\n\n  function scope(event, contentHandler) {\n    return emit(event).then(() => {\n      scopes.push(event);\n      return endScope(event);\n    }).then(contentHandler);\n  }\n\n  function emit() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return (pause || Promise.resolve()).then(() => {\n      try {\n        emitter.emit(...args);\n      } catch (err) {\n        try {\n          emitter.emit(events.error, err);\n        } catch (_) {// When calling user code, anything is possible\n        }\n      }\n    });\n  }\n\n  function endScope(scp) {\n    return awaitNonWhitespace().then(() => {\n      if (character() === terminators[scp]) {\n        return emit(events.endPrefix + scp).then(() => {\n          scopes.pop();\n          return next();\n        }).then(endValue);\n      }\n    }).catch(endWalk);\n  }\n\n  function endValue() {\n    return awaitNonWhitespace().then(after).catch(endWalk);\n\n    function after() {\n      if (scopes.length === 0) {\n        if (shouldHandleNdjson) {\n          return value();\n        }\n\n        return fail(character(), 'EOF', currentPosition).then(value);\n      }\n\n      return checkScope();\n    }\n\n    function checkScope() {\n      const scp = scopes[scopes.length - 1];\n      const handler = handlers[scp];\n      return endScope(scp).then(() => {\n        if (scopes.length > 0) {\n          return checkCharacter(character(), ',', currentPosition);\n        }\n      }).then(result => {\n        if (result) {\n          return next();\n        }\n      }).then(handler);\n    }\n  }\n\n  function fail(actual, expected, position) {\n    return emit(events.dataError, error.create(actual, expected, position.line, position.column));\n  }\n\n  function checkCharacter(char, expected, position) {\n    if (char === expected) {\n      return Promise.resolve(true);\n    }\n\n    return fail(char, expected, position).then(false);\n  }\n\n  function object() {\n    return scope(events.object, property);\n  }\n\n  function property() {\n    return awaitNonWhitespace().then(next).then(propertyName);\n  }\n\n  function propertyName(char) {\n    return checkCharacter(char, '\"', previousPosition).then(() => walkString(events.property)).then(awaitNonWhitespace).then(next).then(propertyValue);\n  }\n\n  function propertyValue(char) {\n    return checkCharacter(char, ':', previousPosition).then(value);\n  }\n\n  function walkString(event) {\n    let isEscaping = false;\n    const str = [];\n    isWalkingString = true;\n    return next().then(step);\n\n    function step(char) {\n      if (isEscaping) {\n        isEscaping = false;\n        return escape(char).then(escaped => {\n          str.push(escaped);\n          return next().then(step);\n        });\n      }\n\n      if (char === '\\\\') {\n        isEscaping = true;\n        return next().then(step);\n      }\n\n      if (char !== '\"') {\n        str.push(char);\n        return next().then(step);\n      }\n\n      isWalkingString = false;\n      return emit(event, str.join(''));\n    }\n  }\n\n  function escape(char) {\n    if (escapes[char]) {\n      return Promise.resolve(escapes[char]);\n    }\n\n    if (char === 'u') {\n      return escapeHex();\n    }\n\n    return fail(char, 'escape character', previousPosition).then(() => `\\\\${char}`);\n  }\n\n  function escapeHex() {\n    let hexits = [];\n    return next().then(step.bind(null, 0));\n\n    function step(idx, char) {\n      if (isHexit(char)) {\n        hexits.push(char);\n      }\n\n      if (idx < 3) {\n        return next().then(step.bind(null, idx + 1));\n      }\n\n      hexits = hexits.join('');\n\n      if (hexits.length === 4) {\n        return String.fromCharCode(parseInt(hexits, 16));\n      }\n\n      return fail(char, 'hex digit', previousPosition).then(() => `\\\\u${hexits}${char}`);\n    }\n  }\n\n  function string() {\n    return walkString(events.string).then(endValue);\n  }\n\n  function number(firstCharacter) {\n    let digits = [firstCharacter];\n    return walkDigits().then(addDigits.bind(null, checkDecimalPlace));\n\n    function addDigits(step, result) {\n      digits = digits.concat(result.digits);\n\n      if (result.atEnd) {\n        return endNumber();\n      }\n\n      return step();\n    }\n\n    function checkDecimalPlace() {\n      if (character() === '.') {\n        return next().then(char => {\n          digits.push(char);\n          return walkDigits();\n        }).then(addDigits.bind(null, checkExponent));\n      }\n\n      return checkExponent();\n    }\n\n    function checkExponent() {\n      if (character() === 'e' || character() === 'E') {\n        return next().then(char => {\n          digits.push(char);\n          return awaitCharacter();\n        }).then(checkSign).catch(fail.bind(null, 'EOF', 'exponent', currentPosition));\n      }\n\n      return endNumber();\n    }\n\n    function checkSign() {\n      if (character() === '+' || character() === '-') {\n        return next().then(char => {\n          digits.push(char);\n          return readExponent();\n        });\n      }\n\n      return readExponent();\n    }\n\n    function readExponent() {\n      return walkDigits().then(addDigits.bind(null, endNumber));\n    }\n\n    function endNumber() {\n      return emit(events.number, parseFloat(digits.join(''))).then(endValue);\n    }\n  }\n\n  function walkDigits() {\n    const digits = [];\n    return wait();\n\n    function wait() {\n      return awaitCharacter().then(step).catch(atEnd);\n    }\n\n    function step() {\n      if (isDigit(character())) {\n        return next().then(char => {\n          digits.push(char);\n          return wait();\n        });\n      }\n\n      return {\n        digits,\n        atEnd: false\n      };\n    }\n\n    function atEnd() {\n      return {\n        digits,\n        atEnd: true\n      };\n    }\n  }\n\n  function literalFalse() {\n    return literal(['a', 'l', 's', 'e'], false);\n  }\n\n  function literal(expectedCharacters, val) {\n    let actual, expected, invalid;\n    return wait();\n\n    function wait() {\n      return awaitCharacter().then(step).catch(atEnd);\n    }\n\n    function step() {\n      if (invalid || expectedCharacters.length === 0) {\n        return atEnd();\n      }\n\n      return next().then(afterNext);\n    }\n\n    function atEnd() {\n      return Promise.resolve().then(() => {\n        if (invalid) {\n          return fail(actual, expected, previousPosition);\n        }\n\n        if (expectedCharacters.length > 0) {\n          return fail('EOF', expectedCharacters.shift(), currentPosition);\n        }\n\n        return done();\n      }).then(endValue);\n    }\n\n    function afterNext(char) {\n      actual = char;\n      expected = expectedCharacters.shift();\n\n      if (actual !== expected) {\n        invalid = true;\n      }\n\n      return wait();\n    }\n\n    function done() {\n      return emit(events.literal, val);\n    }\n  }\n\n  function literalNull() {\n    return literal(['u', 'l', 'l'], null);\n  }\n\n  function literalTrue() {\n    return literal(['r', 'u', 'e'], true);\n  }\n\n  function endStream() {\n    isStreamEnded = true;\n\n    if (isWalkBegun) {\n      return resume();\n    }\n\n    endWalk();\n  }\n\n  function resume() {\n    if (resumeFn) {\n      resumeFn();\n      resumeFn = null;\n    }\n  }\n\n  function endWalk() {\n    if (isWalkEnded) {\n      return Promise.resolve();\n    }\n\n    isWalkEnded = true;\n    return Promise.resolve().then(() => {\n      if (isWalkingString) {\n        return fail('EOF', '\"', currentPosition);\n      }\n    }).then(popScopes).then(() => emit(events.end));\n  }\n\n  function popScopes() {\n    if (scopes.length === 0) {\n      return Promise.resolve();\n    }\n\n    return fail('EOF', terminators[scopes.pop()], currentPosition).then(popScopes);\n  }\n}\n\nfunction isHexit(character) {\n  return isDigit(character) || isInRange(character, 'A', 'F') || isInRange(character, 'a', 'f');\n}\n\nfunction isDigit(character) {\n  return isInRange(character, '0', '9');\n}\n\nfunction isInRange(character, lower, upper) {\n  const code = character.charCodeAt(0);\n  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0);\n}","map":{"version":3,"names":["check","require","error","EventEmitter","events","promise","terminators","obj","arr","escapes","module","exports","initialise","stream","options","assert","instanceStrict","Readable","currentPosition","line","column","emitter","handlers","value","property","json","lengths","previousPosition","Promise","scopes","yieldRate","shouldHandleNdjson","ndjson","index","isStreamEnded","isWalkBegun","isWalkEnded","isWalkingString","hasEndedLine","count","resumeFn","pause","cachedCharacter","setEncoding","on","readStream","endStream","err","emit","resolve","res","end","chunk","addChunk","resume","push","chunkLength","length","item","aggregate","chunkCount","_do","setImmediate","then","awaitNonWhitespace","next","handleValue","catch","wait","awaitCharacter","step","isWhitespace","character","reject","endWalk","after","rej","len","i","char","result","shift","difference","forEach","endLine","fail","array","object","string","number","literalFalse","literalNull","literalTrue","scope","event","contentHandler","endScope","args","_","scp","endPrefix","pop","endValue","checkScope","handler","checkCharacter","actual","expected","position","dataError","create","propertyName","walkString","propertyValue","isEscaping","str","escape","escaped","join","escapeHex","hexits","bind","idx","isHexit","String","fromCharCode","parseInt","firstCharacter","digits","walkDigits","addDigits","checkDecimalPlace","concat","atEnd","endNumber","checkExponent","checkSign","readExponent","parseFloat","isDigit","literal","expectedCharacters","val","invalid","afterNext","done","popScopes","isInRange","lower","upper","code","charCodeAt"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/bfj/src/walk.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst error = require('./error')\nconst EventEmitter = require('events').EventEmitter\nconst events = require('./events')\nconst promise = require('./promise')\n\nconst terminators = {\n  obj: '}',\n  arr: ']'\n}\n\nconst escapes = {\n  /* eslint-disable quote-props */\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  /* eslint-enable quote-props */\n}\n\nmodule.exports = initialise\n\n/**\n * Public function `walk`.\n *\n * Returns an event emitter and asynchronously walks a stream of JSON data,\n * emitting events as it encounters tokens. The event emitter is decorated\n * with a `pause` method that can be called to pause processing.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON.\n **/\nfunction initialise (stream, options = {}) {\n  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument')\n\n  const currentPosition = {\n    line: 1,\n    column: 1\n  }\n  const emitter = new EventEmitter()\n  const handlers = {\n    arr: value,\n    obj: property\n  }\n  const json = []\n  const lengths = []\n  const previousPosition = {}\n  const Promise = promise(options)\n  const scopes = []\n  const yieldRate = options.yieldRate || 16384\n  const shouldHandleNdjson = !! options.ndjson\n\n  let index = 0\n  let isStreamEnded = false\n  let isWalkBegun = false\n  let isWalkEnded = false\n  let isWalkingString = false\n  let hasEndedLine = true\n  let count = 0\n  let resumeFn\n  let pause\n  let cachedCharacter\n\n  stream.setEncoding('utf8')\n  stream.on('data', readStream)\n  stream.on('end', endStream)\n  stream.on('error', err => {\n    emitter.emit(events.error, err)\n    endStream()\n  })\n\n  emitter.pause = () => {\n    let resolve\n    pause = new Promise(res => resolve = res)\n    return () => {\n      pause = null\n      count = 0\n\n      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {\n        emit(events.end)\n      } else {\n        resolve()\n      }\n    }\n  }\n\n  return emitter\n\n  function readStream (chunk) {\n    addChunk(chunk)\n\n    if (isWalkBegun) {\n      return resume()\n    }\n\n    isWalkBegun = true\n    value()\n  }\n\n  function addChunk (chunk) {\n    json.push(chunk)\n\n    const chunkLength = chunk.length\n    lengths.push({\n      item: chunkLength,\n      aggregate: length() + chunkLength\n    })\n  }\n\n  function length () {\n    const chunkCount = lengths.length\n\n    if (chunkCount === 0) {\n      return 0\n    }\n\n    return lengths[chunkCount - 1].aggregate\n  }\n\n  function value () {\n    /* eslint-disable no-underscore-dangle */\n    if (++count % yieldRate !== 0) {\n      return _do()\n    }\n\n    return new Promise(resolve => {\n      setImmediate(() => _do().then(resolve))\n    })\n\n    function _do () {\n      return awaitNonWhitespace()\n        .then(next)\n        .then(handleValue)\n        .catch(() => {})\n    }\n    /* eslint-enable no-underscore-dangle */\n  }\n\n  function awaitNonWhitespace () {\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n    }\n\n    function step () {\n      if (isWhitespace(character())) {\n        return next().then(wait)\n      }\n    }\n  }\n\n  function awaitCharacter () {\n    let resolve, reject\n\n    if (index < length()) {\n      return Promise.resolve()\n    }\n\n    if (isStreamEnded) {\n      setImmediate(endWalk)\n      return Promise.reject()\n    }\n\n    resumeFn = after\n\n    return new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    function after () {\n      if (index < length()) {\n        return resolve()\n      }\n\n      reject()\n\n      if (isStreamEnded) {\n        setImmediate(endWalk)\n      }\n    }\n  }\n\n  function character () {\n    if (cachedCharacter) {\n      return cachedCharacter\n    }\n\n    if (lengths[0].item > index) {\n      return cachedCharacter = json[0][index]\n    }\n\n    const len = lengths.length\n    for (let i = 1; i < len; ++i) {\n      const { aggregate, item } = lengths[i]\n      if (aggregate > index) {\n        return cachedCharacter = json[i][index + item - aggregate]\n      }\n    }\n  }\n\n  function isWhitespace (char) {\n    switch (char) {\n      case '\\n':\n        if (shouldHandleNdjson && scopes.length === 0) {\n          return false\n        }\n      case ' ':\n      case '\\t':\n      case '\\r':\n        return true\n    }\n\n    return false\n  }\n\n  function next () {\n    return awaitCharacter().then(after)\n\n    function after () {\n      const result = character()\n\n      cachedCharacter = null\n      index += 1\n      previousPosition.line = currentPosition.line\n      previousPosition.column = currentPosition.column\n\n      if (result === '\\n') {\n        currentPosition.line += 1\n        currentPosition.column = 1\n      } else {\n        currentPosition.column += 1\n      }\n\n      if (index > lengths[0].aggregate) {\n        json.shift()\n\n        const difference = lengths.shift().item\n        index -= difference\n\n        lengths.forEach(len => len.aggregate -= difference)\n      }\n\n      return result\n    }\n  }\n\n  function handleValue (char) {\n    if (shouldHandleNdjson && scopes.length === 0) {\n      if (char === '\\n') {\n        hasEndedLine = true\n        return emit(events.endLine)\n          .then(value)\n      }\n\n      if (! hasEndedLine) {\n        return fail(char, '\\n', previousPosition)\n          .then(value)\n      }\n\n      hasEndedLine = false\n    }\n\n    switch (char) {\n      case '[':\n        return array()\n      case '{':\n        return object()\n      case '\"':\n        return string()\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n      case '.':\n        return number(char)\n      case 'f':\n        return literalFalse()\n      case 'n':\n        return literalNull()\n      case 't':\n        return literalTrue()\n      default:\n        return fail(char, 'value', previousPosition)\n          .then(value)\n    }\n  }\n\n  function array () {\n    return scope(events.array, value)\n  }\n\n  function scope (event, contentHandler) {\n    return emit(event)\n      .then(() => {\n        scopes.push(event)\n        return endScope(event)\n      })\n      .then(contentHandler)\n  }\n\n  function emit (...args) {\n    return (pause || Promise.resolve())\n      .then(() => {\n        try {\n          emitter.emit(...args)\n        } catch (err) {\n          try {\n            emitter.emit(events.error, err)\n          } catch (_) {\n            // When calling user code, anything is possible\n          }\n        }\n      })\n  }\n\n  function endScope (scp) {\n    return awaitNonWhitespace()\n      .then(() => {\n        if (character() === terminators[scp]) {\n          return emit(events.endPrefix + scp)\n            .then(() => {\n              scopes.pop()\n              return next()\n            })\n            .then(endValue)\n        }\n      })\n      .catch(endWalk)\n  }\n\n  function endValue () {\n    return awaitNonWhitespace()\n      .then(after)\n      .catch(endWalk)\n\n    function after () {\n      if (scopes.length === 0) {\n        if (shouldHandleNdjson) {\n          return value()\n        }\n\n        return fail(character(), 'EOF', currentPosition)\n          .then(value)\n      }\n\n      return checkScope()\n    }\n\n    function checkScope () {\n      const scp = scopes[scopes.length - 1]\n      const handler = handlers[scp]\n\n      return endScope(scp)\n        .then(() => {\n          if (scopes.length > 0) {\n            return checkCharacter(character(), ',', currentPosition)\n          }\n        })\n        .then(result => {\n          if (result) {\n            return next()\n          }\n        })\n        .then(handler)\n    }\n  }\n\n  function fail (actual, expected, position) {\n    return emit(\n      events.dataError,\n      error.create(\n        actual,\n        expected,\n        position.line,\n        position.column\n      )\n    )\n  }\n\n  function checkCharacter (char, expected, position) {\n    if (char === expected) {\n      return Promise.resolve(true)\n    }\n\n    return fail(char, expected, position)\n      .then(false)\n  }\n\n  function object () {\n    return scope(events.object, property)\n  }\n\n  function property () {\n    return awaitNonWhitespace()\n      .then(next)\n      .then(propertyName)\n  }\n\n  function propertyName (char) {\n    return checkCharacter(char, '\"', previousPosition)\n      .then(() => walkString(events.property))\n      .then(awaitNonWhitespace)\n      .then(next)\n      .then(propertyValue)\n  }\n\n  function propertyValue (char) {\n    return checkCharacter(char, ':', previousPosition)\n      .then(value)\n  }\n\n  function walkString (event) {\n    let isEscaping = false\n    const str = []\n\n    isWalkingString = true\n\n    return next().then(step)\n\n    function step (char) {\n      if (isEscaping) {\n        isEscaping = false\n\n        return escape(char).then(escaped => {\n          str.push(escaped)\n          return next().then(step)\n        })\n      }\n\n      if (char === '\\\\') {\n        isEscaping = true\n        return next().then(step)\n      }\n\n      if (char !== '\"') {\n        str.push(char)\n        return next().then(step)\n      }\n\n      isWalkingString = false\n      return emit(event, str.join(''))\n    }\n  }\n\n  function escape (char) {\n    if (escapes[char]) {\n      return Promise.resolve(escapes[char])\n    }\n\n    if (char === 'u') {\n      return escapeHex()\n    }\n\n    return fail(char, 'escape character', previousPosition)\n      .then(() => `\\\\${char}`)\n  }\n\n  function escapeHex () {\n    let hexits = []\n\n    return next().then(step.bind(null, 0))\n\n    function step (idx, char) {\n      if (isHexit(char)) {\n        hexits.push(char)\n      }\n\n      if (idx < 3) {\n        return next().then(step.bind(null, idx + 1))\n      }\n\n      hexits = hexits.join('')\n\n      if (hexits.length === 4) {\n        return String.fromCharCode(parseInt(hexits, 16))\n      }\n\n      return fail(char, 'hex digit', previousPosition)\n        .then(() => `\\\\u${hexits}${char}`)\n    }\n  }\n\n  function string () {\n    return walkString(events.string).then(endValue)\n  }\n\n  function number (firstCharacter) {\n    let digits = [ firstCharacter ]\n\n    return walkDigits().then(addDigits.bind(null, checkDecimalPlace))\n\n    function addDigits (step, result) {\n      digits = digits.concat(result.digits)\n\n      if (result.atEnd) {\n        return endNumber()\n      }\n\n      return step()\n    }\n\n    function checkDecimalPlace () {\n      if (character() === '.') {\n        return next()\n          .then(char => {\n            digits.push(char)\n            return walkDigits()\n          })\n          .then(addDigits.bind(null, checkExponent))\n      }\n\n      return checkExponent()\n    }\n\n    function checkExponent () {\n      if (character() === 'e' || character() === 'E') {\n        return next()\n          .then(char => {\n            digits.push(char)\n            return awaitCharacter()\n          })\n          .then(checkSign)\n          .catch(fail.bind(null, 'EOF', 'exponent', currentPosition))\n      }\n\n      return endNumber()\n    }\n\n    function checkSign () {\n      if (character() === '+' || character() === '-') {\n        return next().then(char => {\n          digits.push(char)\n          return readExponent()\n        })\n      }\n\n      return readExponent()\n    }\n\n    function readExponent () {\n      return walkDigits().then(addDigits.bind(null, endNumber))\n    }\n\n    function endNumber () {\n      return emit(events.number, parseFloat(digits.join('')))\n        .then(endValue)\n    }\n  }\n\n  function walkDigits () {\n    const digits = []\n\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n        .catch(atEnd)\n    }\n\n    function step () {\n      if (isDigit(character())) {\n        return next().then(char => {\n          digits.push(char)\n          return wait()\n        })\n      }\n\n      return { digits, atEnd: false }\n    }\n\n    function atEnd () {\n      return { digits, atEnd: true }\n    }\n  }\n\n  function literalFalse () {\n    return literal([ 'a', 'l', 's', 'e' ], false)\n  }\n\n  function literal (expectedCharacters, val) {\n    let actual, expected, invalid\n\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n        .catch(atEnd)\n    }\n\n    function step () {\n      if (invalid || expectedCharacters.length === 0) {\n        return atEnd()\n      }\n\n      return next().then(afterNext)\n    }\n\n    function atEnd () {\n      return Promise.resolve()\n        .then(() => {\n          if (invalid) {\n            return fail(actual, expected, previousPosition)\n          }\n\n          if (expectedCharacters.length > 0) {\n            return fail('EOF', expectedCharacters.shift(), currentPosition)\n          }\n\n          return done()\n        })\n        .then(endValue)\n    }\n\n    function afterNext (char) {\n      actual = char\n      expected = expectedCharacters.shift()\n\n      if (actual !== expected) {\n        invalid = true\n      }\n\n      return wait()\n    }\n\n    function done () {\n      return emit(events.literal, val)\n    }\n  }\n\n  function literalNull () {\n    return literal([ 'u', 'l', 'l' ], null)\n  }\n\n  function literalTrue () {\n    return literal([ 'r', 'u', 'e' ], true)\n  }\n\n  function endStream () {\n    isStreamEnded = true\n\n    if (isWalkBegun) {\n      return resume()\n    }\n\n    endWalk()\n  }\n\n  function resume () {\n    if (resumeFn) {\n      resumeFn()\n      resumeFn = null\n    }\n  }\n\n  function endWalk () {\n    if (isWalkEnded) {\n      return Promise.resolve()\n    }\n\n    isWalkEnded = true\n\n    return Promise.resolve()\n      .then(() => {\n        if (isWalkingString) {\n          return fail('EOF', '\"', currentPosition)\n        }\n      })\n      .then(popScopes)\n      .then(() => emit(events.end))\n  }\n\n  function popScopes () {\n    if (scopes.length === 0) {\n      return Promise.resolve()\n    }\n\n    return fail('EOF', terminators[scopes.pop()], currentPosition)\n      .then(popScopes)\n  }\n}\n\nfunction isHexit (character) {\n  return isDigit(character) ||\n    isInRange(character, 'A', 'F') ||\n    isInRange(character, 'a', 'f')\n}\n\nfunction isDigit (character) {\n  return isInRange(character, '0', '9')\n}\n\nfunction isInRange (character, lower, upper) {\n  const code = character.charCodeAt(0)\n\n  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}