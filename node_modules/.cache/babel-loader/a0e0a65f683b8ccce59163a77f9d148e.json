{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst ICSSUtils = require('icss-utils');\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nlet options = {};\nlet importIndex = 0;\n\nlet createImportedName = options && options.createImportedName || ((importName\n/*, path*/\n) => `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`);\n\nmodule.exports = postcss.plugin('postcss-modules-values', () => (css, result) => {\n  const importAliases = [];\n  const definitions = {};\n\n  const addDefinition = atRule => {\n    let matches;\n\n    while (matches = matchValueDefinition.exec(atRule.params)) {\n      let [,\n      /*match*/\n      key, value] = matches; // Add to the definitions, knowing that values can refer to each other\n\n      definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n      atRule.remove();\n    }\n  };\n\n  const addImport = atRule => {\n    const matches = matchImports.exec(atRule.params);\n\n    if (matches) {\n      let [,\n      /*match*/\n      aliases, path] = matches; // We can use constants for path names\n\n      if (definitions[path]) {\n        path = definitions[path];\n      }\n\n      const imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(alias => {\n        const tokens = matchImport.exec(alias);\n\n        if (tokens) {\n          const [,\n          /*match*/\n          theirName, myName = theirName] = tokens;\n          const importedName = createImportedName(myName);\n          definitions[myName] = importedName;\n          return {\n            theirName,\n            importedName\n          };\n        } else {\n          throw new Error(`@import statement \"${alias}\" is invalid!`);\n        }\n      });\n      importAliases.push({\n        path,\n        imports\n      });\n      atRule.remove();\n    }\n  };\n  /* Look at all the @value statements and treat them as locals or as imports */\n\n\n  css.walkAtRules('value', atRule => {\n    if (matchImports.exec(atRule.params)) {\n      addImport(atRule);\n    } else {\n      if (atRule.params.indexOf('@value') !== -1) {\n        result.warn('Invalid value definition: ' + atRule.params);\n      }\n\n      addDefinition(atRule);\n    }\n  });\n  /* We want to export anything defined by now, but don't add it to the CSS yet or\n  it well get picked up by the replacement stuff */\n\n  const exportDeclarations = Object.keys(definitions).map(key => postcss.decl({\n    value: definitions[key],\n    prop: key,\n    raws: {\n      before: '\\n  '\n    }\n  }));\n  /* If we have no definitions, don't continue */\n\n  if (!Object.keys(definitions).length) {\n    return;\n  }\n  /* Perform replacements */\n\n\n  ICSSUtils.replaceSymbols(css, definitions);\n  /* Add export rules if any */\n\n  if (exportDeclarations.length > 0) {\n    const exportRule = postcss.rule({\n      selector: ':export',\n      raws: {\n        after: '\\n'\n      }\n    });\n    exportRule.append(exportDeclarations);\n    css.prepend(exportRule);\n  }\n  /* Add import rules */\n\n\n  importAliases.reverse().forEach(_ref => {\n    let {\n      path,\n      imports\n    } = _ref;\n    const importRule = postcss.rule({\n      selector: `:import(${path})`,\n      raws: {\n        after: '\\n'\n      }\n    });\n    imports.forEach(_ref2 => {\n      let {\n        theirName,\n        importedName\n      } = _ref2;\n      importRule.append({\n        value: theirName,\n        prop: importedName,\n        raws: {\n          before: '\\n  '\n        }\n      });\n    });\n    css.prepend(importRule);\n  });\n});","map":{"version":3,"names":["postcss","require","ICSSUtils","matchImports","matchValueDefinition","matchImport","options","importIndex","createImportedName","importName","replace","module","exports","plugin","css","result","importAliases","definitions","addDefinition","atRule","matches","exec","params","key","value","replaceValueSymbols","remove","addImport","aliases","path","imports","split","map","alias","tokens","theirName","myName","importedName","Error","push","walkAtRules","indexOf","warn","exportDeclarations","Object","keys","decl","prop","raws","before","length","replaceSymbols","exportRule","rule","selector","after","append","prepend","reverse","forEach","importRule"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/postcss-modules-values/src/index.js"],"sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst ICSSUtils = require('icss-utils');\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nlet options = {};\nlet importIndex = 0;\nlet createImportedName =\n  (options && options.createImportedName) ||\n  ((importName /*, path*/) =>\n    `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`);\n\nmodule.exports = postcss.plugin(\n  'postcss-modules-values',\n  () => (css, result) => {\n    const importAliases = [];\n    const definitions = {};\n\n    const addDefinition = atRule => {\n      let matches;\n      while ((matches = matchValueDefinition.exec(atRule.params))) {\n        let [, /*match*/ key, value] = matches;\n        // Add to the definitions, knowing that values can refer to each other\n        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n        atRule.remove();\n      }\n    };\n\n    const addImport = atRule => {\n      const matches = matchImports.exec(atRule.params);\n      if (matches) {\n        let [, /*match*/ aliases, path] = matches;\n        // We can use constants for path names\n        if (definitions[path]) {\n          path = definitions[path];\n        }\n        const imports = aliases\n          .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1')\n          .split(/\\s*,\\s*/)\n          .map(alias => {\n            const tokens = matchImport.exec(alias);\n            if (tokens) {\n              const [, /*match*/ theirName, myName = theirName] = tokens;\n              const importedName = createImportedName(myName);\n              definitions[myName] = importedName;\n              return { theirName, importedName };\n            } else {\n              throw new Error(`@import statement \"${alias}\" is invalid!`);\n            }\n          });\n        importAliases.push({ path, imports });\n        atRule.remove();\n      }\n    };\n\n    /* Look at all the @value statements and treat them as locals or as imports */\n    css.walkAtRules('value', atRule => {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n   it well get picked up by the replacement stuff */\n    const exportDeclarations = Object.keys(definitions).map(key =>\n      postcss.decl({\n        value: definitions[key],\n        prop: key,\n        raws: { before: '\\n  ' }\n      })\n    );\n\n    /* If we have no definitions, don't continue */\n    if (!Object.keys(definitions).length) {\n      return;\n    }\n\n    /* Perform replacements */\n    ICSSUtils.replaceSymbols(css, definitions);\n\n    /* Add export rules if any */\n    if (exportDeclarations.length > 0) {\n      const exportRule = postcss.rule({\n        selector: ':export',\n        raws: { after: '\\n' }\n      });\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n\n    /* Add import rules */\n    importAliases.reverse().forEach(({ path, imports }) => {\n      const importRule = postcss.rule({\n        selector: `:import(${path})`,\n        raws: { after: '\\n' }\n      });\n      imports.forEach(({ theirName, importedName }) => {\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: { before: '\\n  ' }\n        });\n      });\n\n      css.prepend(importRule);\n    });\n  }\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}