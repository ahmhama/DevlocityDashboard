{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _webpackSources = _interopRequireDefault(require(\"webpack-sources\"));\n\nvar _CssDependency = _interopRequireDefault(require(\"./CssDependency\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable class-methods-use-this */\n\n\nconst {\n  ConcatSource,\n  SourceMapSource,\n  OriginalSource\n} = _webpackSources.default;\nconst {\n  Template,\n  util: {\n    createHash\n  }\n} = _webpack.default;\nconst MODULE_TYPE = 'css/mini-extract';\nconst pluginName = 'mini-css-extract-plugin';\nconst REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/i;\nconst REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/i;\nconst REGEXP_NAME = /\\[name\\]/i;\nconst REGEXP_PLACEHOLDERS = /\\[(name|id|chunkhash)\\]/g;\nconst DEFAULT_FILENAME = '[name].css';\n\nclass CssDependencyTemplate {\n  apply() {}\n\n}\n\nclass CssModule extends _webpack.default.Module {\n  constructor(dependency) {\n    super(MODULE_TYPE, dependency.context);\n    this.id = '';\n    this._identifier = dependency.identifier;\n    this._identifierIndex = dependency.identifierIndex;\n    this.content = dependency.content;\n    this.media = dependency.media;\n    this.sourceMap = dependency.sourceMap;\n  } // no source() so webpack doesn't do add stuff to the bundle\n\n\n  size() {\n    return this.content.length;\n  }\n\n  identifier() {\n    return `css ${this._identifier} ${this._identifierIndex}`;\n  }\n\n  readableIdentifier(requestShortener) {\n    return `css ${requestShortener.shorten(this._identifier)}${this._identifierIndex ? ` (${this._identifierIndex})` : ''}`;\n  }\n\n  nameForCondition() {\n    const resource = this._identifier.split('!').pop();\n\n    const idx = resource.indexOf('?');\n\n    if (idx >= 0) {\n      return resource.substring(0, idx);\n    }\n\n    return resource;\n  }\n\n  updateCacheModule(module) {\n    this.content = module.content;\n    this.media = module.media;\n    this.sourceMap = module.sourceMap;\n  }\n\n  needRebuild() {\n    return true;\n  }\n\n  build(options, compilation, resolver, fileSystem, callback) {\n    this.buildInfo = {};\n    this.buildMeta = {};\n    callback();\n  }\n\n  updateHash(hash) {\n    super.updateHash(hash);\n    hash.update(this.content);\n    hash.update(this.media || '');\n    hash.update(this.sourceMap ? JSON.stringify(this.sourceMap) : '');\n  }\n\n}\n\nclass CssModuleFactory {\n  create(_ref, callback) {\n    let {\n      dependencies: [dependency]\n    } = _ref;\n    callback(null, new CssModule(dependency));\n  }\n\n}\n\nclass MiniCssExtractPlugin {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = Object.assign({\n      filename: DEFAULT_FILENAME,\n      moduleFilename: () => this.options.filename || DEFAULT_FILENAME,\n      ignoreOrder: false\n    }, options);\n\n    if (!this.options.chunkFilename) {\n      const {\n        filename\n      } = this.options; // Anything changing depending on chunk is fine\n\n      if (filename.match(REGEXP_PLACEHOLDERS)) {\n        this.options.chunkFilename = filename;\n      } else {\n        // Elsewise prefix '[id].' in front of the basename to make it changing\n        this.options.chunkFilename = filename.replace(/(^|\\/)([^/]*(?:\\?|$))/, '$1[id].$2');\n      }\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      compilation.dependencyFactories.set(_CssDependency.default, new CssModuleFactory());\n      compilation.dependencyTemplates.set(_CssDependency.default, new CssDependencyTemplate());\n      compilation.mainTemplate.hooks.renderManifest.tap(pluginName, (result, _ref2) => {\n        let {\n          chunk\n        } = _ref2;\n        const renderedModules = Array.from(chunk.modulesIterable).filter(module => module.type === MODULE_TYPE);\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () => this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener),\n            filenameTemplate: _ref3 => {\n              let {\n                chunk: chunkData\n              } = _ref3;\n              return this.options.moduleFilename(chunkData);\n            },\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE]\n          });\n        }\n      });\n      compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, (result, _ref4) => {\n        let {\n          chunk\n        } = _ref4;\n        const renderedModules = Array.from(chunk.modulesIterable).filter(module => module.type === MODULE_TYPE);\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () => this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener),\n            filenameTemplate: this.options.chunkFilename,\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE]\n          });\n        }\n      });\n      compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, (hash, chunk) => {\n        const {\n          chunkFilename\n        } = this.options;\n\n        if (REGEXP_CHUNKHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n\n        if (REGEXP_CONTENTHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}));\n        }\n\n        if (REGEXP_NAME.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n      compilation.hooks.contentHash.tap(pluginName, chunk => {\n        const {\n          outputOptions\n        } = compilation;\n        const {\n          hashFunction,\n          hashDigest,\n          hashDigestLength\n        } = outputOptions;\n        const hash = createHash(hashFunction);\n\n        for (const m of chunk.modulesIterable) {\n          if (m.type === MODULE_TYPE) {\n            m.updateHash(hash);\n          }\n        }\n\n        const {\n          contentHash\n        } = chunk;\n        contentHash[MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);\n      });\n      const {\n        mainTemplate\n      } = compilation;\n      mainTemplate.hooks.localVars.tap(pluginName, (source, chunk) => {\n        const chunkMap = this.getCssChunkObject(chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(',\\n')), '}']);\n        }\n\n        return source;\n      });\n      mainTemplate.hooks.requireEnsure.tap(pluginName, (source, chunk, hash) => {\n        const chunkMap = this.getCssChunkObject(chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          const chunkMaps = chunk.getChunkMaps();\n          const {\n            crossOriginLoading\n          } = mainTemplate.outputOptions;\n          const linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(this.options.chunkFilename), {\n            hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n            hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n            chunk: {\n              id: '\" + chunkId + \"',\n              hash: `\" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + \"`,\n\n              hashWithLength(length) {\n                const shortChunkHashMap = Object.create(null);\n\n                for (const chunkId of Object.keys(chunkMaps.hash)) {\n                  if (typeof chunkMaps.hash[chunkId] === 'string') {\n                    shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);\n                  }\n                }\n\n                return `\" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + \"`;\n              },\n\n              contentHash: {\n                [MODULE_TYPE]: `\" + ${JSON.stringify(chunkMaps.contentHash[MODULE_TYPE])}[chunkId] + \"`\n              },\n              contentHashWithLength: {\n                [MODULE_TYPE]: length => {\n                  const shortContentHashMap = {};\n                  const contentHash = chunkMaps.contentHash[MODULE_TYPE];\n\n                  for (const chunkId of Object.keys(contentHash)) {\n                    if (typeof contentHash[chunkId] === 'string') {\n                      shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);\n                    }\n                  }\n\n                  return `\" + ${JSON.stringify(shortContentHashMap)}[chunkId] + \"`;\n                }\n              },\n              name: `\" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + \"`\n            },\n            contentHashType: MODULE_TYPE\n          });\n          return Template.asString([source, '', `// ${pluginName} CSS loading`, `var cssChunks = ${JSON.stringify(chunkMap)};`, 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent([`var href = ${linkHrefPath};`, `var fullhref = ${mainTemplate.requireFn}.p + href;`, 'var existingLinkTags = document.getElementsByTagName(\"link\");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");', 'if(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName(\"style\");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute(\"data-href\");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement(\"link\");', 'linkTag.rel = \"stylesheet\";', 'linkTag.type = \"text/css\";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\\\n(\" + request + \")\");', 'err.code = \"CSS_CHUNK_LOAD_FAILED\";', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString([`if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {`, Template.indent(`linkTag.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), '}']) : '', 'var head = document.getElementsByTagName(\"head\")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);\n        }\n\n        return source;\n      });\n    });\n  }\n\n  getCssChunkObject(mainChunk) {\n    const obj = {};\n\n    for (const chunk of mainChunk.getAllAsyncChunks()) {\n      for (const module of chunk.modulesIterable) {\n        if (module.type === MODULE_TYPE) {\n          obj[chunk.id] = 1;\n          break;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  renderContentAsset(compilation, chunk, modules, requestShortener) {\n    let usedModules;\n    const [chunkGroup] = chunk.groupsIterable;\n\n    if (typeof chunkGroup.getModuleIndex2 === 'function') {\n      // Store dependencies for modules\n      const moduleDependencies = new Map(modules.map(m => [m, new Set()]));\n      const moduleDependenciesReasons = new Map(modules.map(m => [m, new Map()])); // Get ordered list of modules per chunk group\n      // This loop also gathers dependencies from the ordered lists\n      // Lists are in reverse order to allow to use Array.pop()\n\n      const modulesByChunkGroup = Array.from(chunk.groupsIterable, cg => {\n        const sortedModules = modules.map(m => {\n          return {\n            module: m,\n            index: cg.getModuleIndex2(m)\n          };\n        }) // eslint-disable-next-line no-undefined\n        .filter(item => item.index !== undefined).sort((a, b) => b.index - a.index).map(item => item.module);\n\n        for (let i = 0; i < sortedModules.length; i++) {\n          const set = moduleDependencies.get(sortedModules[i]);\n          const reasons = moduleDependenciesReasons.get(sortedModules[i]);\n\n          for (let j = i + 1; j < sortedModules.length; j++) {\n            const module = sortedModules[j];\n            set.add(module);\n            const reason = reasons.get(module) || new Set();\n            reason.add(cg);\n            reasons.set(module, reason);\n          }\n        }\n\n        return sortedModules;\n      }); // set with already included modules in correct order\n\n      usedModules = new Set();\n\n      const unusedModulesFilter = m => !usedModules.has(m);\n\n      while (usedModules.size < modules.length) {\n        let success = false;\n        let bestMatch;\n        let bestMatchDeps; // get first module where dependencies are fulfilled\n\n        for (const list of modulesByChunkGroup) {\n          // skip and remove already added modules\n          while (list.length > 0 && usedModules.has(list[list.length - 1])) {\n            list.pop();\n          } // skip empty lists\n\n\n          if (list.length !== 0) {\n            const module = list[list.length - 1];\n            const deps = moduleDependencies.get(module); // determine dependencies that are not yet included\n\n            const failedDeps = Array.from(deps).filter(unusedModulesFilter); // store best match for fallback behavior\n\n            if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {\n              bestMatch = list;\n              bestMatchDeps = failedDeps;\n            }\n\n            if (failedDeps.length === 0) {\n              // use this module and remove it from list\n              usedModules.add(list.pop());\n              success = true;\n              break;\n            }\n          }\n        }\n\n        if (!success) {\n          // no module found => there is a conflict\n          // use list with fewest failed deps\n          // and emit a warning\n          const fallbackModule = bestMatch.pop();\n\n          if (!this.options.ignoreOrder) {\n            const reasons = moduleDependenciesReasons.get(fallbackModule);\n            compilation.warnings.push(new Error([`chunk ${chunk.name || chunk.id} [${pluginName}]`, 'Conflicting order. Following module has been added:', ` * ${fallbackModule.readableIdentifier(requestShortener)}`, 'despite it was not able to fulfill desired ordering with these modules:', ...bestMatchDeps.map(m => {\n              const goodReasonsMap = moduleDependenciesReasons.get(m);\n              const goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);\n              const failedChunkGroups = Array.from(reasons.get(m), cg => cg.name).join(', ');\n              const goodChunkGroups = goodReasons && Array.from(goodReasons, cg => cg.name).join(', ');\n              return [` * ${m.readableIdentifier(requestShortener)}`, `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups}`, goodChunkGroups && `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups}`].filter(Boolean).join('\\n');\n            })].join('\\n')));\n          }\n\n          usedModules.add(fallbackModule);\n        }\n      }\n    } else {\n      // fallback for older webpack versions\n      // (to avoid a breaking change)\n      // TODO remove this in next major version\n      // and increase minimum webpack version to 4.12.0\n      modules.sort((a, b) => a.index2 - b.index2);\n      usedModules = modules;\n    }\n\n    const source = new ConcatSource();\n    const externalsSource = new ConcatSource();\n\n    for (const m of usedModules) {\n      if (/^@import url/.test(m.content)) {\n        // HACK for IE\n        // http://stackoverflow.com/a/14676665/1458162\n        let {\n          content\n        } = m;\n\n        if (m.media) {\n          // insert media into the @import\n          // this is rar\n          // TODO improve this and parse the CSS to support multiple medias\n          content = content.replace(/;|\\s*$/, m.media);\n        }\n\n        externalsSource.add(content);\n        externalsSource.add('\\n');\n      } else {\n        if (m.media) {\n          source.add(`@media ${m.media} {\\n`);\n        }\n\n        if (m.sourceMap) {\n          source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));\n        } else {\n          source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));\n        }\n\n        source.add('\\n');\n\n        if (m.media) {\n          source.add('}\\n');\n        }\n      }\n    }\n\n    return new ConcatSource(externalsSource, source);\n  }\n\n}\n\nMiniCssExtractPlugin.loader = require.resolve('./loader');\nvar _default = MiniCssExtractPlugin;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_webpack","_interopRequireDefault","require","_webpackSources","_CssDependency","obj","__esModule","ConcatSource","SourceMapSource","OriginalSource","Template","util","createHash","MODULE_TYPE","pluginName","REGEXP_CHUNKHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_PLACEHOLDERS","DEFAULT_FILENAME","CssDependencyTemplate","apply","CssModule","Module","constructor","dependency","context","id","_identifier","identifier","_identifierIndex","identifierIndex","content","media","sourceMap","size","length","readableIdentifier","requestShortener","shorten","nameForCondition","resource","split","pop","idx","indexOf","substring","updateCacheModule","module","needRebuild","build","options","compilation","resolver","fileSystem","callback","buildInfo","buildMeta","updateHash","hash","update","JSON","stringify","CssModuleFactory","create","dependencies","MiniCssExtractPlugin","assign","filename","moduleFilename","ignoreOrder","chunkFilename","match","replace","compiler","hooks","thisCompilation","tap","dependencyFactories","set","dependencyTemplates","mainTemplate","renderManifest","result","chunk","renderedModules","Array","from","modulesIterable","filter","type","push","render","renderContentAsset","runtimeTemplate","filenameTemplate","chunkData","pathOptions","contentHashType","contentHash","chunkTemplate","hashForChunk","test","getChunkMaps","name","outputOptions","hashFunction","hashDigest","hashDigestLength","m","digest","localVars","source","chunkMap","getCssChunkObject","keys","asString","indent","ids","map","join","requireEnsure","chunkMaps","crossOriginLoading","linkHrefPath","getAssetPath","renderCurrentHashCode","hashWithLength","shortChunkHashMap","chunkId","contentHashWithLength","shortContentHashMap","requireFn","mainChunk","getAllAsyncChunks","modules","usedModules","chunkGroup","groupsIterable","getModuleIndex2","moduleDependencies","Map","Set","moduleDependenciesReasons","modulesByChunkGroup","cg","sortedModules","index","item","undefined","sort","a","b","i","get","reasons","j","add","reason","unusedModulesFilter","has","success","bestMatch","bestMatchDeps","list","deps","failedDeps","fallbackModule","warnings","Error","goodReasonsMap","goodReasons","failedChunkGroups","goodChunkGroups","Boolean","index2","externalsSource","loader","resolve","_default"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/mini-css-extract-plugin/dist/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _webpackSources = _interopRequireDefault(require(\"webpack-sources\"));\n\nvar _CssDependency = _interopRequireDefault(require(\"./CssDependency\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable class-methods-use-this */\nconst {\n  ConcatSource,\n  SourceMapSource,\n  OriginalSource\n} = _webpackSources.default;\nconst {\n  Template,\n  util: {\n    createHash\n  }\n} = _webpack.default;\nconst MODULE_TYPE = 'css/mini-extract';\nconst pluginName = 'mini-css-extract-plugin';\nconst REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/i;\nconst REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/i;\nconst REGEXP_NAME = /\\[name\\]/i;\nconst REGEXP_PLACEHOLDERS = /\\[(name|id|chunkhash)\\]/g;\nconst DEFAULT_FILENAME = '[name].css';\n\nclass CssDependencyTemplate {\n  apply() {}\n\n}\n\nclass CssModule extends _webpack.default.Module {\n  constructor(dependency) {\n    super(MODULE_TYPE, dependency.context);\n    this.id = '';\n    this._identifier = dependency.identifier;\n    this._identifierIndex = dependency.identifierIndex;\n    this.content = dependency.content;\n    this.media = dependency.media;\n    this.sourceMap = dependency.sourceMap;\n  } // no source() so webpack doesn't do add stuff to the bundle\n\n\n  size() {\n    return this.content.length;\n  }\n\n  identifier() {\n    return `css ${this._identifier} ${this._identifierIndex}`;\n  }\n\n  readableIdentifier(requestShortener) {\n    return `css ${requestShortener.shorten(this._identifier)}${this._identifierIndex ? ` (${this._identifierIndex})` : ''}`;\n  }\n\n  nameForCondition() {\n    const resource = this._identifier.split('!').pop();\n\n    const idx = resource.indexOf('?');\n\n    if (idx >= 0) {\n      return resource.substring(0, idx);\n    }\n\n    return resource;\n  }\n\n  updateCacheModule(module) {\n    this.content = module.content;\n    this.media = module.media;\n    this.sourceMap = module.sourceMap;\n  }\n\n  needRebuild() {\n    return true;\n  }\n\n  build(options, compilation, resolver, fileSystem, callback) {\n    this.buildInfo = {};\n    this.buildMeta = {};\n    callback();\n  }\n\n  updateHash(hash) {\n    super.updateHash(hash);\n    hash.update(this.content);\n    hash.update(this.media || '');\n    hash.update(this.sourceMap ? JSON.stringify(this.sourceMap) : '');\n  }\n\n}\n\nclass CssModuleFactory {\n  create({\n    dependencies: [dependency]\n  }, callback) {\n    callback(null, new CssModule(dependency));\n  }\n\n}\n\nclass MiniCssExtractPlugin {\n  constructor(options = {}) {\n    this.options = Object.assign({\n      filename: DEFAULT_FILENAME,\n      moduleFilename: () => this.options.filename || DEFAULT_FILENAME,\n      ignoreOrder: false\n    }, options);\n\n    if (!this.options.chunkFilename) {\n      const {\n        filename\n      } = this.options; // Anything changing depending on chunk is fine\n\n      if (filename.match(REGEXP_PLACEHOLDERS)) {\n        this.options.chunkFilename = filename;\n      } else {\n        // Elsewise prefix '[id].' in front of the basename to make it changing\n        this.options.chunkFilename = filename.replace(/(^|\\/)([^/]*(?:\\?|$))/, '$1[id].$2');\n      }\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      compilation.dependencyFactories.set(_CssDependency.default, new CssModuleFactory());\n      compilation.dependencyTemplates.set(_CssDependency.default, new CssDependencyTemplate());\n      compilation.mainTemplate.hooks.renderManifest.tap(pluginName, (result, {\n        chunk\n      }) => {\n        const renderedModules = Array.from(chunk.modulesIterable).filter(module => module.type === MODULE_TYPE);\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () => this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener),\n            filenameTemplate: ({\n              chunk: chunkData\n            }) => this.options.moduleFilename(chunkData),\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE]\n          });\n        }\n      });\n      compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, (result, {\n        chunk\n      }) => {\n        const renderedModules = Array.from(chunk.modulesIterable).filter(module => module.type === MODULE_TYPE);\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () => this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener),\n            filenameTemplate: this.options.chunkFilename,\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE]\n          });\n        }\n      });\n      compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, (hash, chunk) => {\n        const {\n          chunkFilename\n        } = this.options;\n\n        if (REGEXP_CHUNKHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n\n        if (REGEXP_CONTENTHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}));\n        }\n\n        if (REGEXP_NAME.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n      compilation.hooks.contentHash.tap(pluginName, chunk => {\n        const {\n          outputOptions\n        } = compilation;\n        const {\n          hashFunction,\n          hashDigest,\n          hashDigestLength\n        } = outputOptions;\n        const hash = createHash(hashFunction);\n\n        for (const m of chunk.modulesIterable) {\n          if (m.type === MODULE_TYPE) {\n            m.updateHash(hash);\n          }\n        }\n\n        const {\n          contentHash\n        } = chunk;\n        contentHash[MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);\n      });\n      const {\n        mainTemplate\n      } = compilation;\n      mainTemplate.hooks.localVars.tap(pluginName, (source, chunk) => {\n        const chunkMap = this.getCssChunkObject(chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(',\\n')), '}']);\n        }\n\n        return source;\n      });\n      mainTemplate.hooks.requireEnsure.tap(pluginName, (source, chunk, hash) => {\n        const chunkMap = this.getCssChunkObject(chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          const chunkMaps = chunk.getChunkMaps();\n          const {\n            crossOriginLoading\n          } = mainTemplate.outputOptions;\n          const linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(this.options.chunkFilename), {\n            hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n            hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n            chunk: {\n              id: '\" + chunkId + \"',\n              hash: `\" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + \"`,\n\n              hashWithLength(length) {\n                const shortChunkHashMap = Object.create(null);\n\n                for (const chunkId of Object.keys(chunkMaps.hash)) {\n                  if (typeof chunkMaps.hash[chunkId] === 'string') {\n                    shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);\n                  }\n                }\n\n                return `\" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + \"`;\n              },\n\n              contentHash: {\n                [MODULE_TYPE]: `\" + ${JSON.stringify(chunkMaps.contentHash[MODULE_TYPE])}[chunkId] + \"`\n              },\n              contentHashWithLength: {\n                [MODULE_TYPE]: length => {\n                  const shortContentHashMap = {};\n                  const contentHash = chunkMaps.contentHash[MODULE_TYPE];\n\n                  for (const chunkId of Object.keys(contentHash)) {\n                    if (typeof contentHash[chunkId] === 'string') {\n                      shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);\n                    }\n                  }\n\n                  return `\" + ${JSON.stringify(shortContentHashMap)}[chunkId] + \"`;\n                }\n              },\n              name: `\" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + \"`\n            },\n            contentHashType: MODULE_TYPE\n          });\n          return Template.asString([source, '', `// ${pluginName} CSS loading`, `var cssChunks = ${JSON.stringify(chunkMap)};`, 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent([`var href = ${linkHrefPath};`, `var fullhref = ${mainTemplate.requireFn}.p + href;`, 'var existingLinkTags = document.getElementsByTagName(\"link\");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");', 'if(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName(\"style\");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute(\"data-href\");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement(\"link\");', 'linkTag.rel = \"stylesheet\";', 'linkTag.type = \"text/css\";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\\\n(\" + request + \")\");', 'err.code = \"CSS_CHUNK_LOAD_FAILED\";', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString([`if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {`, Template.indent(`linkTag.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), '}']) : '', 'var head = document.getElementsByTagName(\"head\")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);\n        }\n\n        return source;\n      });\n    });\n  }\n\n  getCssChunkObject(mainChunk) {\n    const obj = {};\n\n    for (const chunk of mainChunk.getAllAsyncChunks()) {\n      for (const module of chunk.modulesIterable) {\n        if (module.type === MODULE_TYPE) {\n          obj[chunk.id] = 1;\n          break;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  renderContentAsset(compilation, chunk, modules, requestShortener) {\n    let usedModules;\n    const [chunkGroup] = chunk.groupsIterable;\n\n    if (typeof chunkGroup.getModuleIndex2 === 'function') {\n      // Store dependencies for modules\n      const moduleDependencies = new Map(modules.map(m => [m, new Set()]));\n      const moduleDependenciesReasons = new Map(modules.map(m => [m, new Map()])); // Get ordered list of modules per chunk group\n      // This loop also gathers dependencies from the ordered lists\n      // Lists are in reverse order to allow to use Array.pop()\n\n      const modulesByChunkGroup = Array.from(chunk.groupsIterable, cg => {\n        const sortedModules = modules.map(m => {\n          return {\n            module: m,\n            index: cg.getModuleIndex2(m)\n          };\n        }) // eslint-disable-next-line no-undefined\n        .filter(item => item.index !== undefined).sort((a, b) => b.index - a.index).map(item => item.module);\n\n        for (let i = 0; i < sortedModules.length; i++) {\n          const set = moduleDependencies.get(sortedModules[i]);\n          const reasons = moduleDependenciesReasons.get(sortedModules[i]);\n\n          for (let j = i + 1; j < sortedModules.length; j++) {\n            const module = sortedModules[j];\n            set.add(module);\n            const reason = reasons.get(module) || new Set();\n            reason.add(cg);\n            reasons.set(module, reason);\n          }\n        }\n\n        return sortedModules;\n      }); // set with already included modules in correct order\n\n      usedModules = new Set();\n\n      const unusedModulesFilter = m => !usedModules.has(m);\n\n      while (usedModules.size < modules.length) {\n        let success = false;\n        let bestMatch;\n        let bestMatchDeps; // get first module where dependencies are fulfilled\n\n        for (const list of modulesByChunkGroup) {\n          // skip and remove already added modules\n          while (list.length > 0 && usedModules.has(list[list.length - 1])) {\n            list.pop();\n          } // skip empty lists\n\n\n          if (list.length !== 0) {\n            const module = list[list.length - 1];\n            const deps = moduleDependencies.get(module); // determine dependencies that are not yet included\n\n            const failedDeps = Array.from(deps).filter(unusedModulesFilter); // store best match for fallback behavior\n\n            if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {\n              bestMatch = list;\n              bestMatchDeps = failedDeps;\n            }\n\n            if (failedDeps.length === 0) {\n              // use this module and remove it from list\n              usedModules.add(list.pop());\n              success = true;\n              break;\n            }\n          }\n        }\n\n        if (!success) {\n          // no module found => there is a conflict\n          // use list with fewest failed deps\n          // and emit a warning\n          const fallbackModule = bestMatch.pop();\n\n          if (!this.options.ignoreOrder) {\n            const reasons = moduleDependenciesReasons.get(fallbackModule);\n            compilation.warnings.push(new Error([`chunk ${chunk.name || chunk.id} [${pluginName}]`, 'Conflicting order. Following module has been added:', ` * ${fallbackModule.readableIdentifier(requestShortener)}`, 'despite it was not able to fulfill desired ordering with these modules:', ...bestMatchDeps.map(m => {\n              const goodReasonsMap = moduleDependenciesReasons.get(m);\n              const goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);\n              const failedChunkGroups = Array.from(reasons.get(m), cg => cg.name).join(', ');\n              const goodChunkGroups = goodReasons && Array.from(goodReasons, cg => cg.name).join(', ');\n              return [` * ${m.readableIdentifier(requestShortener)}`, `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups}`, goodChunkGroups && `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups}`].filter(Boolean).join('\\n');\n            })].join('\\n')));\n          }\n\n          usedModules.add(fallbackModule);\n        }\n      }\n    } else {\n      // fallback for older webpack versions\n      // (to avoid a breaking change)\n      // TODO remove this in next major version\n      // and increase minimum webpack version to 4.12.0\n      modules.sort((a, b) => a.index2 - b.index2);\n      usedModules = modules;\n    }\n\n    const source = new ConcatSource();\n    const externalsSource = new ConcatSource();\n\n    for (const m of usedModules) {\n      if (/^@import url/.test(m.content)) {\n        // HACK for IE\n        // http://stackoverflow.com/a/14676665/1458162\n        let {\n          content\n        } = m;\n\n        if (m.media) {\n          // insert media into the @import\n          // this is rar\n          // TODO improve this and parse the CSS to support multiple medias\n          content = content.replace(/;|\\s*$/, m.media);\n        }\n\n        externalsSource.add(content);\n        externalsSource.add('\\n');\n      } else {\n        if (m.media) {\n          source.add(`@media ${m.media} {\\n`);\n        }\n\n        if (m.sourceMap) {\n          source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));\n        } else {\n          source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));\n        }\n\n        source.add('\\n');\n\n        if (m.media) {\n          source.add('}\\n');\n        }\n      }\n    }\n\n    return new ConcatSource(externalsSource, source);\n  }\n\n}\n\nMiniCssExtractPlugin.loader = require.resolve('./loader');\nvar _default = MiniCssExtractPlugin;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}