{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst emojisList = require('emojis-list');\n\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter(emoji => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n  emojiCache[content] = emojiEncoding;\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === 'function') {\n    filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n  let query = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path.relative(context, resourcePath + '_').replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n    const hashIdx = query.indexOf('#');\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) => encodeStringToEmoji(content, parseInt(length, 10)));\n  }\n\n  url = url.replace(/\\[ext\\]/gi, () => ext).replace(/\\[name\\]/gi, () => basename).replace(/\\[path\\]/gi, () => directory).replace(/\\[folder\\]/gi, () => folder).replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach((matched, i) => {\n      url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n    });\n  }\n\n  if (typeof loaderContext.options === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;","map":{"version":3,"names":["path","require","emojisList","getHashDigest","emojiRegex","emojiList","filter","emoji","test","emojiCache","encodeStringToEmoji","content","length","emojis","Error","index","Math","floor","random","push","splice","emojiEncoding","join","interpolateName","loaderContext","name","options","filename","hasQuery","resourceQuery","resourcePath","undefined","context","regExp","ext","basename","directory","folder","query","parsed","parse","substr","dir","sep","relative","replace","hashIdx","indexOf","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/loader-utils/lib/interpolateName.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst emojisList = require('emojis-list');\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n\n  emojiCache[content] = emojiEncoding;\n\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === 'function') {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n  let query = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path\n        .relative(context, resourcePath + '_')\n        .replace(/\\\\/g, '/')\n        .replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf('#');\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      )\n      .replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) =>\n        encodeStringToEmoji(content, parseInt(length, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === 'object' &&\n    typeof loaderContext.options.customInterpolateName === 'function'\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}