{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error(`composition is only allowed when selector is single :local class name not in \"${root}\"`);\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== 'pseudo' || node.value !== ':local' || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== 'selector' || node.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig');\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = '0x' + escaped - 0x10000; // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n\n    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n  });\n}\n\nconst processor = postcss.plugin('postcss-modules-scope', function (options) {\n  return css => {\n    const generateScopedName = options && options.generateScopedName || processor.generateScopedName;\n    const generateExportEntry = options && options.generateExportEntry || processor.generateExportEntry;\n    const exportGlobals = options && options.exportGlobals;\n    const exports = Object.create(null);\n\n    function exportScopedName(name, rawName) {\n      const scopedName = generateScopedName(rawName ? rawName : name, css.source.input.from, css.source.input.css);\n      const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, css.source.input.from, css.source.input.css);\n      const {\n        key,\n        value\n      } = exportEntry;\n      exports[key] = exports[key] || [];\n\n      if (exports[key].indexOf(value) < 0) {\n        exports[key].push(value);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      switch (node.type) {\n        case 'selector':\n          node.nodes = node.map(localizeNode);\n          return node;\n\n        case 'class':\n          return selectorParser.className({\n            value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n          });\n\n        case 'id':\n          {\n            return selectorParser.id({\n              value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n            });\n          }\n      }\n\n      throw new Error(`${node.type} (\"${node}\") is not allowed in a :local block`);\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'pseudo':\n          if (node.value === ':local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            const selector = localizeNode(node.first, node.spaces); // move the spaces that were around the psuedo selector to the first\n            // non-container node\n\n            selector.first.spaces = node.spaces;\n            const nextNode = node.next();\n\n            if (nextNode && nextNode.type === 'combinator' && nextNode.value === ' ' && /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)) {\n              selector.last.spaces.after = ' ';\n            }\n\n            node.replaceWith(selector);\n            return;\n          }\n\n        /* falls through */\n\n        case 'root':\n        case 'selector':\n          {\n            node.each(traverseNode);\n            break;\n          }\n\n        case 'id':\n        case 'class':\n          if (exportGlobals) {\n            exports[node.value] = [node.value];\n          }\n\n          break;\n      }\n\n      return node;\n    } // Find any :import and remember imported names\n\n\n    const importedNames = {};\n    css.walkRules(rule => {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }\n    }); // Find any :local classes\n\n    css.walkRules(rule => {\n      if (rule.nodes && rule.selector.slice(0, 2) === '--' && rule.selector.slice(-1) === ':') {\n        // ignore custom property set\n        return;\n      }\n\n      let parsedSelector = selectorParser().astSync(rule);\n      rule.selector = traverseNode(parsedSelector.clone()).toString();\n      rule.walkDecls(/composes|compose-with/, decl => {\n        const localNames = getSingleLocalNamesForComposes(parsedSelector);\n        const classes = decl.value.split(/\\s+/);\n        classes.forEach(className => {\n          const global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(exportedName => {\n              exports[className].forEach(item => {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error(`referenced class name \"${className}\" in ${decl.prop} not found`);\n          }\n        });\n        decl.remove();\n      });\n      rule.walkDecls(decl => {\n        let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n        tokens = tokens.map((token, idx) => {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            const localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return localMatch[1] + exportScopedName(localMatch[2]) + token.substr(localMatch[0].length);\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n        decl.value = tokens.join('');\n      });\n    }); // Find any :local keyframes\n\n    css.walkAtRules(atrule => {\n      if (/keyframes$/i.test(atrule.name)) {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    }); // If we found any :locals, insert an :export rule\n\n    const exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      const exportRule = postcss.rule({\n        selector: ':export'\n      });\n      exportedNames.forEach(exportedName => exportRule.append({\n        prop: exportedName,\n        value: exports[exportedName].join(' '),\n        raws: {\n          before: '\\n  '\n        }\n      }));\n      css.append(exportRule);\n    }\n  };\n});\n\nprocessor.generateScopedName = function (name, path) {\n  const sanitisedPath = path.replace(/\\.[^\\.\\/\\\\]+$/, '').replace(/[\\W_]+/g, '_').replace(/^_|_$/g, '');\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nprocessor.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName)\n  };\n};\n\nmodule.exports = processor;","map":{"version":3,"names":["postcss","require","selectorParser","hasOwnProperty","Object","prototype","getSingleLocalNamesForComposes","root","nodes","map","node","type","length","Error","value","first","whitespace","unescapeRegExp","RegExp","unescape","str","replace","_","escaped","escapedWhitespace","high","String","fromCharCode","processor","plugin","options","css","generateScopedName","generateExportEntry","exportGlobals","exports","create","exportScopedName","name","rawName","scopedName","source","input","from","exportEntry","key","indexOf","push","localizeNode","className","raws","id","traverseNode","selector","spaces","nextNode","next","test","last","after","replaceWith","each","importedNames","walkRules","rule","walkDecls","decl","prop","slice","parsedSelector","astSync","clone","toString","localNames","classes","split","forEach","global","exec","exportedName","call","item","error","remove","tokens","token","idx","localMatch","substr","join","walkAtRules","atrule","params","exportedNames","keys","exportRule","append","before","path","sanitisedPath","trim","module"],"sources":["C:/Users/Lenovo/Desktop/New folder (2)/strikingDash/node_modules/postcss-modules-scope/src/index.js"],"sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst selectorParser = require('postcss-selector-parser');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== 'pseudo' ||\n      node.value !== ':local' ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'selector' || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp(\n  '\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)',\n  'ig'\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = '0x' + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n        ? // BMP codepoint\n          String.fromCharCode(high + 0x10000)\n        : // Supplemental Plane codepoint (surrogate pair)\n          String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst processor = postcss.plugin('postcss-modules-scope', function(options) {\n  return css => {\n    const generateScopedName =\n      (options && options.generateScopedName) || processor.generateScopedName;\n    const generateExportEntry =\n      (options && options.generateExportEntry) || processor.generateExportEntry;\n    const exportGlobals = options && options.exportGlobals;\n\n    const exports = Object.create(null);\n\n    function exportScopedName(name, rawName) {\n      const scopedName = generateScopedName(\n        rawName ? rawName : name,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const exportEntry = generateExportEntry(\n        rawName ? rawName : name,\n        scopedName,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const { key, value } = exportEntry;\n\n      exports[key] = exports[key] || [];\n\n      if (exports[key].indexOf(value) < 0) {\n        exports[key].push(value);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      switch (node.type) {\n        case 'selector':\n          node.nodes = node.map(localizeNode);\n          return node;\n        case 'class':\n          return selectorParser.className({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        case 'id': {\n          return selectorParser.id({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        }\n      }\n\n      throw new Error(\n        `${node.type} (\"${node}\") is not allowed in a :local block`\n      );\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'pseudo':\n          if (node.value === ':local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            const selector = localizeNode(node.first, node.spaces);\n            // move the spaces that were around the psuedo selector to the first\n            // non-container node\n            selector.first.spaces = node.spaces;\n\n            const nextNode = node.next();\n\n            if (\n              nextNode &&\n              nextNode.type === 'combinator' &&\n              nextNode.value === ' ' &&\n              /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n            ) {\n              selector.last.spaces.after = ' ';\n            }\n\n            node.replaceWith(selector);\n\n            return;\n          }\n        /* falls through */\n        case 'root':\n        case 'selector': {\n          node.each(traverseNode);\n          break;\n        }\n        case 'id':\n        case 'class': \n          if (exportGlobals) {\n            exports[node.value] = [node.value];\n          }\n          break;\n      }\n      return node;\n    }\n\n    // Find any :import and remember imported names\n    const importedNames = {};\n\n    css.walkRules(rule => {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }\n    });\n\n    // Find any :local classes\n    css.walkRules(rule => {\n      if (\n        rule.nodes &&\n        rule.selector.slice(0, 2) === '--' &&\n        rule.selector.slice(-1) === ':'\n      ) {\n        // ignore custom property set\n        return;\n      }\n\n      let parsedSelector = selectorParser().astSync(rule);\n\n      rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n      rule.walkDecls(/composes|compose-with/, decl => {\n        const localNames = getSingleLocalNamesForComposes(parsedSelector);\n        const classes = decl.value.split(/\\s+/);\n\n        classes.forEach(className => {\n          const global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(exportedName => {\n              exports[className].forEach(item => {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error(\n              `referenced class name \"${className}\" in ${decl.prop} not found`\n            );\n          }\n        });\n\n        decl.remove();\n      });\n\n      rule.walkDecls(decl => {\n        let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n        tokens = tokens.map((token, idx) => {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            const localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return (\n                localMatch[1] +\n                exportScopedName(localMatch[2]) +\n                token.substr(localMatch[0].length)\n              );\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n\n        decl.value = tokens.join('');\n      });\n    });\n\n    // Find any :local keyframes\n    css.walkAtRules(atrule => {\n      if (/keyframes$/i.test(atrule.name)) {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    });\n\n    // If we found any :locals, insert an :export rule\n    const exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      const exportRule = postcss.rule({ selector: ':export' });\n\n      exportedNames.forEach(exportedName =>\n        exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(' '),\n          raws: { before: '\\n  ' },\n        })\n      );\n\n      css.append(exportRule);\n    }\n  };\n});\n\nprocessor.generateScopedName = function(name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^\\.\\/\\\\]+$/, '')\n    .replace(/[\\W_]+/g, '_')\n    .replace(/^_|_$/g, '');\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nprocessor.generateExportEntry = function(name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = processor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}