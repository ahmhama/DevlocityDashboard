{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // This is a legacy function.\n// Use `findNumbers()` instead.\n\n\nimport { PLUS_CHARS, VALID_PUNCTUATION, VALID_DIGITS, WHITESPACE } from './constants.js';\nimport parse from './parse_.js';\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from './helpers/isViablePhoneNumber.js';\nimport createExtensionPattern from './helpers/extension/createExtensionPattern.js';\nimport parsePreCandidate from './findNumbers/parsePreCandidate.js';\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate.js';\nimport isValidCandidate from './findNumbers/isValidCandidate.js';\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\n\nexport var EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing');\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\nexport default function findPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  var phones = [];\n\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\nexport function searchPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\nexport var PhoneNumberSearch = /*#__PURE__*/function () {\n  function PhoneNumberSearch(text, options, metadata) {\n    _classCallCheck(this, PhoneNumberSearch);\n\n    this.text = text; // If assigning the `{}` default value is moved to the arguments above,\n    // code coverage would decrease for some weird reason.\n\n    this.options = options || {};\n    this.metadata = metadata; // Iteration tristate.\n\n    this.state = 'NOT_READY';\n    this.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig');\n  }\n\n  _createClass(PhoneNumberSearch, [{\n    key: \"find\",\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n\n      if (!matches) {\n        return;\n      }\n\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = parsePreCandidate(number);\n      var result = this.parseCandidate(number, startsAt);\n\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n\n      return this.find();\n    }\n  }, {\n    key: \"parseCandidate\",\n    value: function parseCandidate(number, startsAt) {\n      if (!isValidPreCandidate(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n\n      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n\n      var result = parse(number, this.options, this.metadata);\n\n      if (!result.phone) {\n        return;\n      }\n\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n\n      return this.state === 'READY';\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n\n  return PhoneNumberSearch;\n}();","map":{"version":3,"sources":["../source/findPhoneNumbers_.js"],"names":["EXTN_PATTERNS_FOR_PARSING","createExtensionPattern","WHITESPACE_IN_THE_BEGINNING_PATTERN","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","options","search","phones","Symbol","next","done","value","PhoneNumberSearch","matches","number","startsAt","parsePreCandidate","result","isValidPreCandidate","isValidCandidate","parse"],"mappings":"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","sourcesContent":["// This is a legacy function.\r\n// Use `findNumbers()` instead.\r\n\r\nimport {\r\n\tPLUS_CHARS,\r\n\tVALID_PUNCTUATION,\r\n\tVALID_DIGITS,\r\n\tWHITESPACE\r\n} from './constants.js'\r\n\r\nimport parse from './parse_.js'\r\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from './helpers/isViablePhoneNumber.js'\r\nimport createExtensionPattern from './helpers/extension/createExtensionPattern.js'\r\n\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate.js'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate.js'\r\nimport isValidCandidate from './findNumbers/isValidCandidate.js'\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport const EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing')\r\n\r\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\r\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\r\n\r\n// // Regular expression for getting opening brackets for a valid number\r\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\r\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\r\n\r\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\r\n\r\nexport default function findPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\tconst phones = []\r\n\twhile (search.hasNext()) {\r\n\t\tphones.push(search.next())\r\n\t}\r\n\treturn phones\r\n}\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport function searchPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (search.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: search.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\r\nexport class PhoneNumberSearch {\r\n\tconstructor(text, options, metadata) {\r\n\t\tthis.text = text\r\n\t\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t\t// code coverage would decrease for some weird reason.\r\n\t\tthis.options = options || {}\r\n\t\tthis.metadata = metadata\r\n\r\n\t\t// Iteration tristate.\r\n\t\tthis.state = 'NOT_READY'\r\n\r\n\t\tthis.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig')\r\n\t}\r\n\r\n\tfind() {\r\n\t\tconst matches = this.regexp.exec(this.text)\r\n\t\tif (!matches) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet number = matches[0]\r\n\t\tlet startsAt = matches.index\r\n\r\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\r\n\t\tstartsAt += matches[0].length - number.length\r\n\t\t// Fixes not parsing numbers with whitespace in the end.\r\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\r\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\r\n\r\n\t\tnumber = parsePreCandidate(number)\r\n\r\n\t\tconst result = this.parseCandidate(number, startsAt)\r\n\t\tif (result) {\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// Tail recursion.\r\n\t\t// Try the next one if this one is not a valid phone number.\r\n\t\treturn this.find()\r\n\t}\r\n\r\n\tparseCandidate(number, startsAt) {\r\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Don't parse phone numbers which are non-phone numbers\r\n\t\t// due to being part of something else (e.g. a UUID).\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\r\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\r\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// // Prepend any opening brackets left behind by the\r\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\r\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\r\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\r\n\t\t// if (full_number_starts_at >= 0)\r\n\t\t// {\r\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\r\n\t\t// \tstartsAt = full_number_starts_at\r\n\t\t// }\r\n\t\t//\r\n\t\t// this.searching_from = matches.lastIndex\r\n\r\n\t\tconst result = parse(number, this.options, this.metadata)\r\n\t\tif (!result.phone) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tresult.startsAt = startsAt\r\n\t\tresult.endsAt = startsAt + number.length\r\n\t\treturn result\r\n\t}\r\n\r\n\thasNext() {\r\n\t\tif (this.state === 'NOT_READY') {\r\n\t\t\tthis.last_match = this.find()\r\n\t\t\tif (this.last_match) {\r\n\t\t\t\tthis.state = 'READY'\r\n\t\t\t} else {\r\n\t\t\t\tthis.state = 'DONE'\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.state === 'READY'\r\n\t}\r\n\r\n\tnext() {\r\n\t\t// Check the state and find the next match as a side-effect if necessary.\r\n\t\tif (!this.hasNext()) {\r\n\t\t\tthrow new Error('No next element')\r\n\t\t}\r\n\t\t// Don't retain that memory any longer than necessary.\r\n\t\tconst result = this.last_match\r\n\t\tthis.last_match = null\r\n\t\tthis.state = 'NOT_READY'\r\n\t\treturn result\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}